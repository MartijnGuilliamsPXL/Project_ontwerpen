CCS PCH C Compiler, Version 5.079d, 1               05-jul-18 09:25
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   L:\Projects\13xxxx\130549-I [DS] 9 Channel Relay Control Board with PC Interface\02_lab\firmware\9 ch relay uart_Header\9ch_relay_uart.lst

               ROM used:   4738 bytes (14%)
                           Largest free fragment is 28026
               RAM used:   173 (11%) at main() level
                           244 (16%) worst case
               Stack used: 7 locations (3 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   10BA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00BA
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0746
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... /* 
.................... Project name: 9 Channel Relay Control Board with PC Interface 
.................... MCU used:    PIC18F45K22-E/P 
.................... Description:This relay board has a wide range of applications in the automation sector. Controlling lights, fans and other appliances for home & office automation automatically by PC software and by direct user command settings through UART. 
....................  
.................... FUNCTION 
....................    RECEIVE COMMANDS FROM PC VIA UART AND MAKE RESPACTIVE RELAY ON OR OFF AS PER COMMAND 
....................    DISPLAY & UPDATE THE STATUS OF THE RELAYS ON LCD  
....................    READ 9 KEY MATRIX KEYBOARD AND MAKE REAPACTIVE RELAY TOGGLE ITS STATE 
....................    IF ANY RELAY STATE IS ALTERED BY PRESSING THE KEY, SEND UPDATE RELAY STATUS MESSAGE TO PC VIA UART  
....................  
.................... */ 
....................  
....................  
....................  
....................  
.................... #include <9ch_relay_uart.h> 
.................... #include <18F45K22.h> 
.................... //////////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F45K22 
*
01A4:  TBLRD*+
01A6:  MOVF   FF5,F
01A8:  BZ    01C4
01AA:  MOVFF  FF6,D3
01AE:  MOVFF  FF7,D4
01B2:  MOVF   FF5,W
01B4:  BTFSS  F9E.4
01B6:  BRA    01B4
01B8:  MOVWF  FAD
01BA:  MOVFF  D3,FF6
01BE:  MOVFF  D4,FF7
01C2:  BRA    01A4
01C4:  RETURN 0
*
036E:  MOVFF  33,FEA
0372:  MOVFF  32,FE9
0376:  MOVFF  F1,FEF
037A:  INCF   FE9,F
037C:  BTFSC  FD8.2
037E:  INCF   FEA,F
0380:  CLRF   FEF
0382:  INCF   32,F
0384:  BTFSC  FD8.2
0386:  INCF   33,F
0388:  RETURN 0
038A:  TBLRD*+
038C:  MOVFF  FF6,EC
0390:  MOVFF  FF7,ED
0394:  MOVFF  FF5,F1
0398:  RCALL  036E
039A:  MOVFF  EC,FF6
039E:  MOVFF  ED,FF7
03A2:  DECFSZ xEB,F
03A4:  BRA    038A
03A6:  RETURN 0
03A8:  MOVF   xF2,W
03AA:  CLRF   01
03AC:  SUBWF  xF1,W
03AE:  BC    03B6
03B0:  MOVFF  F1,00
03B4:  BRA    03CE
03B6:  CLRF   00
03B8:  MOVLW  08
03BA:  MOVWF  xF3
03BC:  RLCF   xF1,F
03BE:  RLCF   00,F
03C0:  MOVF   xF2,W
03C2:  SUBWF  00,W
03C4:  BTFSC  FD8.0
03C6:  MOVWF  00
03C8:  RLCF   01,F
03CA:  DECFSZ xF3,F
03CC:  BRA    03BC
03CE:  RETURN 0
03D0:  MOVLW  20
03D2:  BTFSS  xEC.4
03D4:  MOVLW  30
03D6:  MOVWF  xED
03D8:  MOVFF  EB,00
03DC:  BTFSS  xEB.7
03DE:  BRA    03F0
03E0:  COMF   00,F
03E2:  INCF   00,F
03E4:  MOVFF  00,EB
03E8:  MOVLW  2D
03EA:  MOVWF  xED
03EC:  BSF    xEC.7
03EE:  BSF    xEC.0
03F0:  MOVF   01,W
03F2:  MOVFF  EB,F1
03F6:  MOVLW  64
03F8:  MOVWF  xF2
03FA:  RCALL  03A8
03FC:  MOVFF  00,EB
0400:  MOVLW  30
0402:  ADDWF  01,W
0404:  MOVWF  xEE
0406:  MOVFF  EB,F1
040A:  MOVLW  0A
040C:  MOVWF  xF2
040E:  RCALL  03A8
0410:  MOVLW  30
0412:  ADDWF  00,W
0414:  MOVWF  xF0
0416:  MOVLW  30
0418:  ADDWF  01,W
041A:  MOVWF  xEF
041C:  MOVFF  ED,00
0420:  MOVLW  30
0422:  SUBWF  xEE,W
0424:  BZ    042E
0426:  BSF    xEC.1
0428:  BTFSC  xEC.7
042A:  BSF    xEC.2
042C:  BRA    0452
042E:  MOVFF  ED,EE
0432:  MOVLW  20
0434:  MOVWF  xED
0436:  MOVLW  30
0438:  SUBWF  xEF,W
043A:  BZ    0444
043C:  BSF    xEC.0
043E:  BTFSC  xEC.7
0440:  BSF    xEC.1
0442:  BRA    0452
0444:  BTFSS  FD8.2
0446:  BSF    xEC.0
0448:  BNZ   0452
044A:  MOVFF  EE,EF
044E:  MOVLW  20
0450:  MOVWF  xEE
0452:  BTFSC  xEC.2
0454:  BRA    0460
0456:  BTFSC  xEC.1
0458:  BRA    0466
045A:  BTFSC  xEC.0
045C:  BRA    046C
045E:  BRA    0472
0460:  MOVFF  ED,F1
0464:  RCALL  036E
0466:  MOVFF  EE,F1
046A:  RCALL  036E
046C:  MOVFF  EF,F1
0470:  RCALL  036E
0472:  MOVFF  F0,F1
0476:  RCALL  036E
0478:  RETURN 0
047A:  MOVF   FEF,F
047C:  BZ    049E
047E:  MOVFF  FEA,EC
0482:  MOVFF  FE9,EB
0486:  MOVF   FEF,W
0488:  BTFSS  F9E.4
048A:  BRA    0488
048C:  MOVWF  FAD
048E:  MOVFF  EC,FEA
0492:  MOVFF  EB,FE9
0496:  INCF   FE9,F
0498:  BTFSC  FD8.2
049A:  INCF   FEA,F
049C:  BRA    047A
049E:  RETURN 0
*
071A:  ADDWF  FE8,W
071C:  CLRF   FF7
071E:  RLCF   FF7,F
0720:  ADDLW  35
0722:  MOVWF  FF6
0724:  MOVLW  07
0726:  ADDWFC FF7,F
0728:  TBLRD*-
072A:  MOVF   FF5,W
072C:  MOVWF  FFA
072E:  TBLRD*
0730:  MOVF   FF5,W
0732:  MOVWF  FF9
0734:  DATA F8,05
0736:  DATA 12,06
0738:  DATA 2C,06
073A:  DATA 46,06
073C:  DATA 60,06
073E:  DATA 7A,06
0740:  DATA 94,06
0742:  DATA AE,06
0744:  DATA C8,06
*
0780:  DATA 52,45
0782:  DATA 4C,41
0784:  DATA 59,25
0786:  DATA 64,20
0788:  DATA 53,57
078A:  DATA 49,54
078C:  DATA 43,48
078E:  DATA 45,44
0790:  DATA 20,4F
0792:  DATA 4E,00
0794:  DATA 52,45
0796:  DATA 4C,41
0798:  DATA 59,25
079A:  DATA 64,20
079C:  DATA 53,57
079E:  DATA 49,54
07A0:  DATA 43,48
07A2:  DATA 45,44
07A4:  DATA 20,4F
07A6:  DATA 46,46
07A8:  DATA 00,00
07AA:  DATA 3D,3D
07AC:  DATA 3D,3D
07AE:  DATA 3D,3D
07B0:  DATA 3D,3D
07B2:  DATA 3D,3D
07B4:  DATA 3D,3D
07B6:  DATA 3D,3D
07B8:  DATA 3D,3D
07BA:  DATA 3D,3D
07BC:  DATA 3D,3D
07BE:  DATA 3D,3D
07C0:  DATA 3D,3D
07C2:  DATA 3D,3D
07C4:  DATA 3D,3D
07C6:  DATA 3D,3D
07C8:  DATA 3D,3D
07CA:  DATA 3D,3D
07CC:  DATA 3D,3D
07CE:  DATA 3D,3D
07D0:  DATA 3D,3D
07D2:  DATA 3D,3D
07D4:  DATA 3D,3D
07D6:  DATA 3D,3D
07D8:  DATA 3D,3D
07DA:  DATA 3D,3D
07DC:  DATA 3D,3D
07DE:  DATA 3D,3D
07E0:  DATA 3D,3D
07E2:  DATA 3D,3D
07E4:  DATA 3D,3D
07E6:  DATA 3D,3D
07E8:  DATA 3D,3D
07EA:  DATA 3D,3D
07EC:  DATA 3D,3D
07EE:  DATA 3D,3D
07F0:  DATA 3D,3D
07F2:  DATA 3D,3D
07F4:  DATA 3D,3D
07F6:  DATA 3D,3D
07F8:  DATA 3D,3D
07FA:  DATA 3D,3D
07FC:  DATA 3D,3D
07FE:  DATA 3D,3D
0800:  DATA 00,00
0802:  DATA 45,6C
0804:  DATA 65,6B
0806:  DATA 74,6F
0808:  DATA 72,28
080A:  DATA 43,29
080C:  DATA 00,00
080E:  DATA 50,72
0810:  DATA 6F,6A
0812:  DATA 65,63
0814:  DATA 74,20
0816:  DATA 4E,61
0818:  DATA 6D,65
081A:  DATA 3A,20
081C:  DATA 39,20
081E:  DATA 43,68
0820:  DATA 61,6E
0822:  DATA 6E,65
0824:  DATA 6C,20
0826:  DATA 52,65
0828:  DATA 6C,61
082A:  DATA 79,20
082C:  DATA 43,6F
082E:  DATA 6E,74
0830:  DATA 72,6F
0832:  DATA 6C,20
0834:  DATA 42,6F
0836:  DATA 61,72
0838:  DATA 64,20
083A:  DATA 77,69
083C:  DATA 74,68
083E:  DATA 20,50
0840:  DATA 43,20
0842:  DATA 49,6E
0844:  DATA 74,65
0846:  DATA 72,66
0848:  DATA 61,63
084A:  DATA 65,00
084C:  DATA 50,72
084E:  DATA 6F,6A
0850:  DATA 65,63
0852:  DATA 74,20
0854:  DATA 4E,75
0856:  DATA 6D,62
0858:  DATA 65,72
085A:  DATA 3A,20
085C:  DATA 31,33
085E:  DATA 30,35
0860:  DATA 34,39
0862:  DATA 2D,31
0864:  DATA 00,00
0866:  DATA 56,65
0868:  DATA 72,73
086A:  DATA 69,6F
086C:  DATA 6E,20
086E:  DATA 31,2E
0870:  DATA 31,00
0872:  DATA 3D,3D
0874:  DATA 3D,3D
0876:  DATA 3D,3D
0878:  DATA 3D,3D
087A:  DATA 3D,3D
087C:  DATA 3D,3D
087E:  DATA 3D,3D
0880:  DATA 3D,3D
0882:  DATA 3D,3D
0884:  DATA 3D,3D
0886:  DATA 3D,3D
0888:  DATA 3D,3D
088A:  DATA 3D,3D
088C:  DATA 3D,3D
088E:  DATA 3D,3D
0890:  DATA 3D,3D
0892:  DATA 3D,3D
0894:  DATA 3D,3D
0896:  DATA 3D,3D
0898:  DATA 3D,3D
089A:  DATA 3D,3D
089C:  DATA 3D,3D
089E:  DATA 3D,3D
08A0:  DATA 3D,3D
08A2:  DATA 3D,3D
08A4:  DATA 3D,3D
08A6:  DATA 3D,3D
08A8:  DATA 3D,3D
08AA:  DATA 3D,3D
08AC:  DATA 3D,3D
08AE:  DATA 3D,3D
08B0:  DATA 3D,3D
08B2:  DATA 3D,3D
08B4:  DATA 3D,3D
08B6:  DATA 3D,3D
08B8:  DATA 3D,3D
08BA:  DATA 3D,3D
08BC:  DATA 3D,3D
08BE:  DATA 3D,3D
08C0:  DATA 3D,3D
08C2:  DATA 3D,3D
08C4:  DATA 3D,3D
08C6:  DATA 3D,3D
08C8:  DATA 00,00
08CA:  DATA 49,4E
08CC:  DATA 53,54
08CE:  DATA 52,55
08D0:  DATA 43,54
08D2:  DATA 49,4F
08D4:  DATA 4E,53
08D6:  DATA 20,46
08D8:  DATA 4F,52
08DA:  DATA 20,50
08DC:  DATA 43,20
08DE:  DATA 43,4F
08E0:  DATA 4D,4D
08E2:  DATA 41,4E
08E4:  DATA 44,53
08E6:  DATA 3A,00
08E8:  DATA 24,52
08EA:  DATA 4C,59
08EC:  DATA 23,4F
08EE:  DATA 4E,26
08F0:  DATA 20,3A
08F2:  DATA 20,54
08F4:  DATA 55,52
08F6:  DATA 4E,20
08F8:  DATA 41,20
08FA:  DATA 52,45
08FC:  DATA 4C,41
08FE:  DATA 59,20
0900:  DATA 4F,4E
0902:  DATA 20,28
0904:  DATA 52,45
0906:  DATA 50,4C
0908:  DATA 41,43
090A:  DATA 45,20
090C:  DATA 23,20
090E:  DATA 42,59
0910:  DATA 20,52
0912:  DATA 45,4C
0914:  DATA 41,59
0916:  DATA 20,4E
0918:  DATA 55,4D
091A:  DATA 42,45
091C:  DATA 52,20
091E:  DATA 31,20
0920:  DATA 54,4F
0922:  DATA 20,39
0924:  DATA 29,00
0926:  DATA 24,52
0928:  DATA 4C,59
092A:  DATA 23,4F
092C:  DATA 46,46
092E:  DATA 26,3A
0930:  DATA 20,54
0932:  DATA 55,52
0934:  DATA 4E,20
0936:  DATA 41,20
0938:  DATA 52,45
093A:  DATA 4C,41
093C:  DATA 59,20
093E:  DATA 4F,46
0940:  DATA 46,20
0942:  DATA 28,52
0944:  DATA 45,50
0946:  DATA 4C,41
0948:  DATA 43,45
094A:  DATA 20,23
094C:  DATA 20,42
094E:  DATA 59,20
0950:  DATA 52,45
0952:  DATA 4C,41
0954:  DATA 59,20
0956:  DATA 4E,55
0958:  DATA 4D,42
095A:  DATA 45,52
095C:  DATA 20,31
095E:  DATA 20,54
0960:  DATA 4F,20
0962:  DATA 39,29
0964:  DATA 00,00
0966:  DATA 24,48
0968:  DATA 26,20
096A:  DATA 20,20
096C:  DATA 20,20
096E:  DATA 20,3A
0970:  DATA 20,53
0972:  DATA 48,4F
0974:  DATA 57,20
0976:  DATA 54,48
0978:  DATA 45,20
097A:  DATA 48,45
097C:  DATA 4C,50
097E:  DATA 20,50
0980:  DATA 41,47
0982:  DATA 45,20
0984:  DATA 41,47
0986:  DATA 41,49
0988:  DATA 4E,00
098A:  DATA 24,53
098C:  DATA 54,41
098E:  DATA 54,45
0990:  DATA 26,20
0992:  DATA 20,3A
0994:  DATA 20,50
0996:  DATA 52,49
0998:  DATA 4E,54
099A:  DATA 20,54
099C:  DATA 48,45
099E:  DATA 20,43
09A0:  DATA 55,52
09A2:  DATA 52,45
09A4:  DATA 4E,54
09A6:  DATA 20,53
09A8:  DATA 54,41
09AA:  DATA 54,45
09AC:  DATA 53,20
09AE:  DATA 4F,46
09B0:  DATA 20,54
09B2:  DATA 48,45
09B4:  DATA 20,52
09B6:  DATA 45,4C
09B8:  DATA 41,59
09BA:  DATA 53,00
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(internal=16MHz)    // set internal oscillator use at 16MHz 
09BC:  CLRF   FEA
09BE:  MOVLW  AD
09C0:  MOVWF  FE9
09C2:  MOVF   FEF,W
09C4:  BZ    09E2
09C6:  MOVLW  05
09C8:  MOVWF  01
09CA:  CLRF   00
09CC:  DECFSZ 00,F
09CE:  BRA    09CC
09D0:  DECFSZ 01,F
09D2:  BRA    09CA
09D4:  MOVLW  2E
09D6:  MOVWF  00
09D8:  DECFSZ 00,F
09DA:  BRA    09D8
09DC:  BRA    09DE
09DE:  DECFSZ FEF,F
09E0:  BRA    09C6
09E2:  RETURN 0
.................... #use FIXED_IO( A_outputs=PIN_A7,PIN_A6,PIN_A5,PIN_A4,PIN_A3,PIN_A2,PIN_A1,PIN_A0 ) 
.................... #use FIXED_IO( B_outputs=PIN_B4,PIN_B3,PIN_B0 ) 
.................... #use FIXED_IO( C_outputs=PIN_C3,PIN_C2,PIN_C1,PIN_C0 ) 
.................... #use FIXED_IO( D_outputs=PIN_D1,PIN_D2 ) 
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 ) 
.................... #define RLY7   PIN_A0 
.................... #define RLY6   PIN_A1 
.................... #define RLY5   PIN_A2 
.................... #define RLY4   PIN_A3 
.................... #define RLY3   PIN_A4 
.................... #define RLY2   PIN_A5 
.................... #define D6   PIN_A6 
.................... #define D7   PIN_A7 
.................... #define KBD_R1   PIN_B0 
.................... #define KBD_C2   PIN_B1 
.................... #define KBD_C1   PIN_B2 
.................... #define KBD_R2   PIN_B3 
.................... #define KBD_R3   PIN_B4 
.................... #define KBD_C3   PIN_B5 
.................... #define D5   PIN_C0 
.................... #define D4   PIN_C1 
.................... #define LCD_BKLT   PIN_C2 
.................... #define LCD_EN   PIN_C3 
.................... #define LCD_RS   PIN_D1 
.................... #define RLY1   PIN_E0 
.................... #define RLY8   PIN_E1 
.................... #define RLY9   PIN_E2 
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
....................  
.................... #define LED PIN_D2 
.................... #define DELAY 1000 
....................  
.................... #define lcd_line1 0x80 
.................... #define lcd_line2 0xC0 
.................... #define lcd_line3 0x80+20 
.................... #define lcd_line4 0xC0+20 
....................  
....................  
.................... void keyboard_routine(void); 
.................... void report_relay_states(void); 
.................... void send_relay_status(unsigned char rel); 
....................  
.................... int check_data(void); 
.................... void lcd_init(void); 
.................... void send_lcd_command (unsigned char c_data); 
.................... void send_lcd_data (unsigned char c_data); 
.................... void lcd_data (void); 
.................... void lcd_cmd (void); 
.................... void put_lcd_data_h (unsigned char c_lcd_data); 
.................... void put_lcd_data_l (unsigned char c_lcd_data); 
.................... void display_clear_line_1(void); 
.................... void display_clear_line_2(void); 
.................... void display_clear_line_3(void); 
.................... void display_clear_line_4(void); 
.................... void display_clear_line_all(void); 
.................... void display_status_line1(void); 
.................... void display_status_line3(void); 
.................... void display_startup_message (void); 
.................... void display_relay_status(void); 
.................... void send_startup_message(void); 
....................  
....................  
....................  
....................  
....................  
.................... int1 b_sw1 = 1; 
.................... int1 b_sw2 = 1; 
.................... int1 b_sw3 = 1; 
.................... int1 b_sw4 = 1; 
.................... int1 b_sw5 = 1; 
.................... int1 b_sw6 = 1; 
.................... int1 b_sw7 = 1; 
.................... int1 b_sw8 = 1; 
.................... int1 b_sw9 = 1; 
....................  
....................  
.................... unsigned char c_kbd_scan = 1;  
....................  
.................... unsigned char c_serial_buffer[7]; 
.................... unsigned char c_serial_buffer_counter; 
.................... int b_relay_changed = 0; 
....................  
.................... unsigned int32 l_bklt_tout_counter = 300000; 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <float.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* float.h  */ 
....................  
....................  
.................... #ifndef _FLOAT 
.................... #define _FLOAT 
....................     /* Float properties */ 
....................  
.................... #define FLT_RADIX       2 
.................... #define FLT_MANT_DIG    24                              // # of bits in mantissa 
....................  
.................... #define FLT_DIG         6                               // # of decimal digits of precision 
....................  
.................... #define FLT_MIN_EXP     (-125)                          // min binary exponent 
.................... #define FLT_MIN_10_EXP  (-37)                           // min decimal exponent 
.................... #define FLT_MAX_EXP     128                             // max binary exponent 
.................... #define FLT_MAX_10_EXP  38                              // max decimal exponent 
.................... #define FLT_MAX         3.402823466e+38F                // max value 
.................... #define FLT_EPSILON     1.192092896e-07F                // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define FLT_MIN         1.175494351e-38F                // min positive value 
....................  
....................  
....................       /* Double properties */ 
.................... #define DBL_MANT_DIG    53                              // # of bits in mantissa 
....................  
.................... #define DBL_DIG         15                              // # of decimal digits of precision 
....................  
.................... #define DBL_MIN_EXP     (-1021)                         // min binary exponent 
.................... #define DBL_MIN_10_EXP  (-307)                          // min decimal exponent 
.................... #define DBL_MAX_EXP     1024                            // max binary exponent 
.................... #define DBL_MAX_10_EXP  308                             // max decimal exponent 
.................... #define DBL_MAX         1.79769313486231e+308F          // max value 
.................... #define DBL_EPSILON     2.2204460492503131e-16F         // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define DBL_MIN         2.22507385850721e-308F          // min positive value 
....................  
....................          /*Long double properties */ 
....................           
.................... #define LDBL_MANT_DIG    64                             // # of bits in mantissa 
....................  
.................... #define LDBL_DIG         18                             // # of decimal digits of precision 
....................  
.................... #define LDBL_MIN_EXP     (-16381)                       // min binary exponent 
.................... #define LDBL_MIN_10_EXP  (-4931)                        // min decimal exponent 
.................... #define LDBL_MAX_EXP     16384                          // max binary exponent 
.................... #define LDBL_MAX_10_EXP  4932                           // max decimal exponent 
.................... #define LDBL_MAX         1.18973149535723176502e+4932F  // max value 
.................... #define LDBL_EPSILON     1.084202172485504434e-019F     // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define LDBL_MIN         3.36210314311209350626e-4932F  // min positive value 
.................... #endif 
....................  
....................  
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
02E6:  MOVFF  D4,03
02EA:  MOVFF  D3,FE9
02EE:  MOVFF  D4,FEA
02F2:  MOVF   FEF,F
02F4:  BZ    0364
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
02F6:  MOVFF  D4,D8
02FA:  MOVFF  D3,D7
02FE:  MOVFF  D6,DA
0302:  MOVFF  D5,D9
0306:  MOVFF  DA,03
030A:  MOVFF  D9,FE9
030E:  MOVFF  DA,FEA
0312:  MOVF   FEF,F
0314:  BZ    0342
0316:  MOVFF  D7,FE9
031A:  MOVFF  D8,FEA
031E:  MOVFF  FEF,DB
0322:  MOVFF  DA,03
0326:  MOVFF  D9,FE9
032A:  MOVFF  DA,FEA
032E:  MOVF   FEF,W
0330:  SUBWF  xDB,W
0332:  BNZ   0342
0334:  INCF   xD7,F
0336:  BTFSC  FD8.2
0338:  INCF   xD8,F
033A:  INCF   xD9,F
033C:  BTFSC  FD8.2
033E:  INCF   xDA,F
0340:  BRA    0306
....................  
....................       if (*t == '\0') 
0342:  MOVFF  DA,03
0346:  MOVFF  D9,FE9
034A:  MOVFF  03,FEA
034E:  MOVF   FEF,F
0350:  BNZ   035C
....................          return s1; 
0352:  MOVFF  D3,01
0356:  MOVFF  D4,02
035A:  BRA    036A
....................       ++s1; 
035C:  INCF   xD3,F
035E:  BTFSC  FD8.2
0360:  INCF   xD4,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0362:  BRA    02E6
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
0364:  MOVLW  00
0366:  MOVWF  01
0368:  MOVWF  02
036A:  GOTO   0700 (RETURN)
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... #define INT8_C(val) ((int8_t)val) 
.................... #define UINT8_C(val) ((uint8_t)val) 
.................... #define INT16_C(val) ((int16_t)val) 
.................... #define UINT16_C(val) ((uint16_t)val) 
.................... #define INT32_C(val) ((int32_t)val) 
.................... #define UINT32_C(val) ((uint32_t)val) 
....................  
.................... #if defined(__PCD__) 
.................... #define INT64_C(val) ((int64_t)val) 
.................... #define UINT64_C(val) ((uint64_t)val) 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <input.c>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             input.c                               //// 
.................... ////                                                                   //// 
.................... //// Routines for reading user input over an RS232 stream.  User input //// 
.................... //// is in ASCII form and converted to requested binary or float       //// 
.................... //// format.                                                           //// 
.................... ////                                                                   //// 
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  //// 
.................... //// that serial stream.  If not, uses the last #use rs232().          //// 
.................... ////                                                                   //// 
.................... //// Some of these routines are not available unless you #include      //// 
.................... //// string.h and stdlib.h                                             //// 
.................... ////                                                                   //// 
.................... ////  int8 gethex() - read 2 char hex value from serial                //// 
.................... ////                                                                   //// 
.................... ////  get_string(s, max) - read max chars from serial and save to s    //// 
.................... ////                                                                   //// 
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   //// 
.................... ////     displays current string in s, allowing you to edit it.        //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8() -                                              //// 
.................... ////  int16 = get_Int16() -                                            //// 
.................... ////  int32 = get_Int32() -                                            //// 
.................... ////  float = get_float() -                                            //// 
.................... ////     Read value from serial.                                       //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8Edit(old) -                                       //// 
.................... ////  int16 = get_Int16Edit(old) -                                     //// 
.................... ////  int32 = get_Int32Edit(old) -                                     //// 
.................... ////  float = get_floatEdit(old) -                                     //// 
.................... ////     Similar to get_Int*() routines documented above, but first    //// 
.................... ////     it displays old value allowing you to edit it.                //// 
.................... ////                                                                   //// 
.................... ////  int = get_int() -                                                //// 
.................... ////  long = get_long() -                                              //// 
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   //// 
.................... ////     'long' datatypes.  The size of these datatypes depends on     //// 
.................... ////     the PIC architecture and compiler configuration.              //// 
.................... ////                                                                   //// 
.................... ////  int = get_intEdit(old) -                                         //// 
.................... ////  long = get_longEdit(old) -                                       //// 
.................... ////     Similar to get_int() and get_long() documented above,         //// 
.................... ////     but first it displays old value allowing you to edit it.      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __INPUT_C__ 
.................... #define __INPUT_C__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #ifndef InputKbhit 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT) 
....................    #else 
....................       #define InputKbhit()    kbhit() 
....................    #endif 
.................... #endif 
....................  
.................... #if !definedinc(InputPutc) 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       void InputPutc(char c)    {fputc(c, STREAM_SERIAL_INPUT);} 
....................    #else 
....................       void InputPutc(char c)    {putc(c);} 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef InputGetc 
....................    #if defined(STREAM_SERIAL_INPUT) 
....................       #define InputGetc()    fgetc(STREAM_SERIAL_INPUT) 
....................    #else 
....................       #define InputGetc()    getc() 
....................    #endif 
.................... #endif 
....................  
.................... unsigned int8 gethex1() { 
....................    char digit; 
....................  
....................    digit = InputGetc(); 
....................  
....................    InputPutc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... unsigned int8 gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    max-=2; 
....................    len=0; 
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... #ifdef _STRING 
.................... void get_stringEdit(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    len = strlen(s); 
....................  
....................    if (len) 
....................    { 
....................      #if defined(STREAM_SERIAL_INPUT) 
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s); 
....................      #else 
....................       printf(InputPutc, "%s", s); 
....................      #endif 
....................    } 
....................  
....................    max-=2; 
....................  
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
.................... #endif 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... signed int8 get_Int8(void) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int8 get_Int8Edit(signed int8 old) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   sprintf(s, "%d", old); 
....................   get_stringEdit(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... signed int16 get_Int16(void) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int16 get_Int16Edit(signed int16 old) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... signed int32 get_Int32(void) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int32 get_Int32Edit(signed int32 old) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... float get_floatEdit(float old) { 
....................   char s[20]; 
....................   float f; 
....................  
....................   sprintf(s, "%f", old); 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................    #define get_int()       get_Int16() 
....................    #define get_intEdit()   get_Int16Edit() 
....................    #define get_long()      get_Int32() 
....................    #define get_longEdit()  get_Int32Edit() 
.................... #else 
....................    #define get_int()       get_Int8() 
....................    #define get_intEdit()   get_Int8Edit() 
....................    #define get_long()      get_Int16() 
....................    #define get_longEdit()  get_Int16Edit() 
.................... #endif 
....................  
.................... #endif   //_STDLIB 
....................  
.................... #endif   //__INPUT_C__ 
....................  
....................  
.................... #INT_TIMER1 
.................... void  TIMER1_isr(void)  // Timer 1 INTERRUPT 
.................... { 
....................    set_timer1(0xFC17);  // reload timer for 1ms overflow 
*
00BA:  MOVLW  FC
00BC:  MOVWF  FCF
00BE:  MOVLW  17
00C0:  MOVWF  FCE
.................... /*Read Matrizx keyboard 
.................... HERE EVERY 1MS THE KEYBOARD SWITCHES ARE READ BY ACTIVATING ONE ROW AT A TIME OF KEYBOARD MATRIX 
.................... AS MATRIX IS 3 X 3 SO EACH ROW IS CONNECTED TO 3 SWITCHES, HENCE WE ARE READING 3 SWITCHED SIMULTENOIUSLY EVERY 1MS 
.................... SO ALL 9 SWITCHES ARE READ IN 3MS 
....................  
.................... THE KEY STATUS IS STORED IN VARIABLES b_sw1 to b_sw9 for respactive switches 
.................... */ 
....................    switch(c_kbd_scan) 
00C2:  MOVF   1C,W
00C4:  XORLW  01
00C6:  BZ    00D2
00C8:  XORLW  03
00CA:  BZ    0104
00CC:  XORLW  01
00CE:  BZ    0136
00D0:  BRA    0166
....................    { 
....................       case 1: 
....................       { 
....................          b_sw3 = input(KBD_C1); 
00D2:  MOVLW  E6
00D4:  MOVWF  F93
00D6:  BCF    1A.2
00D8:  BTFSC  F81.2
00DA:  BSF    1A.2
....................          b_sw6 = input(KBD_C2); 
00DC:  MOVLW  E6
00DE:  MOVWF  F93
00E0:  BCF    1A.5
00E2:  BTFSC  F81.1
00E4:  BSF    1A.5
....................          b_sw9 = input(KBD_C3); 
00E6:  MOVLW  E6
00E8:  MOVWF  F93
00EA:  BCF    1B.0
00EC:  BTFSC  F81.5
00EE:  BSF    1B.0
....................           
....................          output_low(KBD_R1); 
00F0:  MOVLW  E6
00F2:  MOVWF  F93
00F4:  BCF    F8A.0
....................          output_high(KBD_R2); 
00F6:  MOVWF  F93
00F8:  BSF    F8A.3
....................          output_high(KBD_R3); 
00FA:  MOVWF  F93
00FC:  BSF    F8A.4
....................          c_kbd_scan = 2; 
00FE:  MOVLW  02
0100:  MOVWF  1C
....................       } 
....................       break; 
0102:  BRA    0166
....................        
....................       case 2: 
....................       { 
....................          b_sw1 = input(KBD_C1); 
0104:  MOVLW  E6
0106:  MOVWF  F93
0108:  BCF    1A.0
010A:  BTFSC  F81.2
010C:  BSF    1A.0
....................          b_sw4 = input(KBD_C2); 
010E:  MOVLW  E6
0110:  MOVWF  F93
0112:  BCF    1A.3
0114:  BTFSC  F81.1
0116:  BSF    1A.3
....................          b_sw7 = input(KBD_C3); 
0118:  MOVLW  E6
011A:  MOVWF  F93
011C:  BCF    1A.6
011E:  BTFSC  F81.5
0120:  BSF    1A.6
....................           
....................          output_high(KBD_R1); 
0122:  MOVLW  E6
0124:  MOVWF  F93
0126:  BSF    F8A.0
....................          output_low(KBD_R2); 
0128:  MOVWF  F93
012A:  BCF    F8A.3
....................          output_high(KBD_R3); 
012C:  MOVWF  F93
012E:  BSF    F8A.4
....................          c_kbd_scan = 3; 
0130:  MOVLW  03
0132:  MOVWF  1C
....................       } 
....................       break; 
0134:  BRA    0166
....................        
....................       case 3: 
....................       { 
....................          b_sw2 = input(KBD_C1); 
0136:  MOVLW  E6
0138:  MOVWF  F93
013A:  BCF    1A.1
013C:  BTFSC  F81.2
013E:  BSF    1A.1
....................          b_sw5 = input(KBD_C2); 
0140:  MOVLW  E6
0142:  MOVWF  F93
0144:  BCF    1A.4
0146:  BTFSC  F81.1
0148:  BSF    1A.4
....................          b_sw8 = input(KBD_C3); 
014A:  MOVLW  E6
014C:  MOVWF  F93
014E:  BCF    1A.7
0150:  BTFSC  F81.5
0152:  BSF    1A.7
....................           
....................          output_high(KBD_R1); 
0154:  MOVLW  E6
0156:  MOVWF  F93
0158:  BSF    F8A.0
....................          output_high(KBD_R2); 
015A:  MOVWF  F93
015C:  BSF    F8A.3
....................          output_low(KBD_R3); 
015E:  MOVWF  F93
0160:  BCF    F8A.4
....................          c_kbd_scan = 1; 
0162:  MOVLW  01
0164:  MOVWF  1C
....................       } 
....................       break; 
....................        
....................    } 
....................     
.................... /* 
....................    MAKING LCD BACKLIGHT OFF AFTER GIVEN TIME 
.................... */ 
....................    if(input_state(LCD_BKLT) == 1) 
0166:  BTFSS  F82.2
0168:  BRA    019E
....................    { 
....................       l_bklt_tout_counter--; 
016A:  MOVLW  FF
016C:  ADDWF  26,F
016E:  BTFSS  FD8.0
0170:  ADDWF  27,F
0172:  BTFSS  FD8.0
0174:  ADDWF  28,F
0176:  BTFSS  FD8.0
0178:  ADDWF  29,F
....................       if(l_bklt_tout_counter == 0) 
017A:  MOVF   26,F
017C:  BNZ   019E
017E:  MOVF   27,F
0180:  BNZ   019E
0182:  MOVF   28,F
0184:  BNZ   019E
0186:  MOVF   29,F
0188:  BNZ   019E
....................       { 
....................          output_low(LCD_BKLT); 
018A:  MOVLW  F0
018C:  MOVWF  F94
018E:  BCF    F8B.2
....................          l_bklt_tout_counter = 300000;  // RELOAD BACKLIGHT TIMEOUT COUNTER 
0190:  CLRF   29
0192:  MOVLW  04
0194:  MOVWF  28
0196:  MOVLW  93
0198:  MOVWF  27
019A:  MOVLW  E0
019C:  MOVWF  26
....................       } 
....................    } 
....................     
....................     
.................... } 
....................  
....................  
.................... /* 
.................... HERE IN UART RECEIVE INTERRUPT ROUTNE, AT EVERY RECEIVE INTERRUPT WE CHECK FOR START AND END OF COMMAND 
.................... BY COMPAIRING $ AND & SIGN. BETWEEN THESE TWO SIGN LIES THE COMMAND WORD, WHICH IS STORED IN SERIAL BUFFER 
.................... */ 
....................  
019E:  BCF    F9E.0
01A0:  GOTO   006C
.................... #INT_RDA    // UART receive interrupt 
.................... void  RDA_isr(void)  
.................... { 
.................... unsigned char c_buff_temp; 
....................  
....................    c_buff_temp = getc(); 
*
0746:  BTFSS  F9E.5
0748:  BRA    0746
074A:  MOVFF  FAE,CB
....................    if(c_buff_temp == '$')  // CHECK FOR START COMMAND INDICATOR AS THE $ SIGN IS USED AS START INDICATOR IN COMMAND 
074E:  MOVF   xCB,W
0750:  SUBLW  24
0752:  BNZ   0758
....................    { 
....................       c_serial_buffer_counter = 0;  // RESET UART BUFFER COUNTER 
0754:  CLRF   24
....................    } 
0756:  BRA    077A
....................    else 
....................    { 
....................       if(c_buff_temp == '&') // CHECK FOR END OF COMMAND INDICATOR AS THE & SIGN IS USED AS END OF COMMAND INDICATOR IN COMMAND 
0758:  MOVF   xCB,W
075A:  SUBLW  26
075C:  BNZ   0766
....................       { 
....................          b_relay_changed = check_data(); 
075E:  BRA    05A6
0760:  MOVFF  01,25
....................       } 
0764:  BRA    077A
....................       else 
....................       { 
....................          c_serial_buffer[c_serial_buffer_counter] = c_buff_temp;  // TAKE DATA IN UART BUFFER, ADDRESS IS PROVIDED BY BUFFER COUNTER 
0766:  CLRF   03
0768:  MOVF   24,W
076A:  ADDLW  1D
076C:  MOVWF  FE9
076E:  MOVLW  00
0770:  ADDWFC 03,W
0772:  MOVWF  FEA
0774:  MOVFF  CB,FEF
....................          c_serial_buffer_counter++;          
0778:  INCF   24,F
....................       } 
....................    } 
....................     
....................     
077A:  BCF    F9E.5
077C:  GOTO   006C
.................... } 
....................  
....................  
....................  
....................  
.................... void main() 
*
10BA:  CLRF   FF8
10BC:  BCF    FD0.7
10BE:  BSF    07.7
10C0:  MOVLW  70
10C2:  MOVWF  FD3
10C4:  BCF    F9B.6
10C6:  BCF    F9B.7
10C8:  BSF    FB8.3
10CA:  MOVLW  A0
10CC:  MOVWF  FAF
10CE:  MOVLW  01
10D0:  MOVWF  FB0
10D2:  MOVLW  A6
10D4:  MOVWF  FAC
10D6:  MOVLW  90
10D8:  MOVWF  FAB
10DA:  BSF    1A.0
10DC:  BSF    1A.1
10DE:  BSF    1A.2
10E0:  BSF    1A.3
10E2:  BSF    1A.4
10E4:  BSF    1A.5
10E6:  BSF    1A.6
10E8:  BSF    1A.7
10EA:  BSF    1B.0
10EC:  MOVLW  01
10EE:  MOVWF  1C
10F0:  CLRF   25
10F2:  CLRF   29
10F4:  MOVLW  04
10F6:  MOVWF  28
10F8:  MOVLW  93
10FA:  MOVWF  27
10FC:  MOVLW  E0
10FE:  MOVWF  26
1100:  CLRF   33
1102:  CLRF   32
1104:  MOVLB  F
1106:  CLRF   x38
1108:  CLRF   x39
110A:  CLRF   x3A
110C:  CLRF   x3B
110E:  CLRF   x3C
1110:  CLRF   F77
1112:  CLRF   F78
1114:  CLRF   F79
1116:  CLRF   31
1118:  MOVLW  F4
111A:  MOVWF  30
111C:  MOVLW  05
111E:  MOVLB  0
1120:  MOVWF  xF5
1122:  MOVLW  08
1124:  MOVWF  xF4
1126:  CLRF   xF7
1128:  CLRF   xF6
112A:  BRA    11AC
112C:  DATA 02,00
112E:  DATA 2A,00
1130:  DATA 00,24
1132:  DATA 00,34
1134:  DATA 52,45
1136:  DATA 31,20
1138:  DATA 52,45
113A:  DATA 32,20
113C:  DATA 52,45
113E:  DATA 33,20
1140:  DATA 52,45
1142:  DATA 34,20
1144:  DATA 52,45
1146:  DATA 35,00
1148:  DATA 52,45
114A:  DATA 36,20
114C:  DATA 52,45
114E:  DATA 37,20
1150:  DATA 52,45
1152:  DATA 38,20
1154:  DATA 52,45
1156:  DATA 39,00
1158:  DATA 05,C0
115A:  DATA 20,0A
115C:  DATA 80,45
115E:  DATA 6C,65
1160:  DATA 6B,74
1162:  DATA 6F,72
1164:  DATA 28,43
1166:  DATA 29,05
1168:  DATA C0,20
116A:  DATA 16,80
116C:  DATA 00,20
116E:  DATA 20,39
1170:  DATA 20,43
1172:  DATA 68,20
1174:  DATA 52,65
1176:  DATA 6C,61
1178:  DATA 79,20
117A:  DATA 42,6F
117C:  DATA 61,72
117E:  DATA 64,20
1180:  DATA 20,00
1182:  DATA 06,C0
1184:  DATA 20,08
1186:  DATA 80,31
1188:  DATA 33,30
118A:  DATA 35,34
118C:  DATA 39,2D
118E:  DATA 31,06
1190:  DATA C0,20
1192:  DATA 01,80
1194:  DATA 00,04
1196:  DATA C0,20
1198:  DATA 0B,80
119A:  DATA 56,65
119C:  DATA 72,73
119E:  DATA 69,6F
11A0:  DATA 6E,20
11A2:  DATA 31,2E
11A4:  DATA 30,05
11A6:  DATA C0,20
11A8:  DATA 01,80
11AA:  DATA 00,00
11AC:  MOVLW  00
11AE:  MOVWF  FF8
11B0:  MOVLW  11
11B2:  MOVWF  FF7
11B4:  MOVLW  2C
11B6:  MOVWF  FF6
11B8:  TBLRD*+
11BA:  MOVF   FF5,W
11BC:  MOVWF  00
11BE:  XORLW  00
11C0:  BZ    11E8
11C2:  TBLRD*+
11C4:  MOVF   FF5,W
11C6:  MOVWF  01
11C8:  BTFSC  FE8.7
11CA:  BRA    11D6
11CC:  ANDLW  0F
11CE:  MOVWF  FEA
11D0:  TBLRD*+
11D2:  MOVFF  FF5,FE9
11D6:  BTFSC  01.6
11D8:  TBLRD*+
11DA:  BTFSS  01.6
11DC:  TBLRD*+
11DE:  MOVFF  FF5,FEE
11E2:  DCFSNZ 00,F
11E4:  BRA    11B8
11E6:  BRA    11DA
11E8:  CLRF   FF8
.................... { 
....................    port_B_pullups(0xFF); 
11EA:  SETF   F61
11EC:  BCF    FF1.7
....................    port_E_pullups(0xFF); 
11EE:  MOVLW  E8
11F0:  MOVWF  F96
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_4);      //65.5 ms overflow 
11F2:  MOVLW  27
11F4:  MOVWF  FCD
11F6:  CLRF   FCC
....................    output_low(RLY1); 
11F8:  MOVLW  E8
11FA:  MOVWF  F96
11FC:  BCF    F8D.0
....................    output_low(RLY2); 
11FE:  MOVLW  00
1200:  MOVWF  F92
1202:  BCF    F89.5
....................    output_low(RLY3); 
1204:  MOVWF  F92
1206:  BCF    F89.4
....................    output_low(RLY4); 
1208:  MOVWF  F92
120A:  BCF    F89.3
....................    output_low(RLY5); 
120C:  MOVWF  F92
120E:  BCF    F89.2
....................    output_low(RLY6); 
1210:  MOVWF  F92
1212:  BCF    F89.1
....................    output_low(RLY7); 
1214:  MOVWF  F92
1216:  BCF    F89.0
....................    output_low(RLY8); 
1218:  MOVLW  E8
121A:  MOVWF  F96
121C:  BCF    F8D.1
....................    output_low(RLY9);    // MAKE ALL RELAY OFF 
121E:  MOVWF  F96
1220:  BCF    F8D.2
....................  
....................  
....................    enable_interrupts(INT_TIMER1);   // ENABLE TIMER1 INTERRUPT 
1222:  BSF    F9D.0
....................    enable_interrupts(INT_RDA);      // ENABLE UART RECEIVE INTERRUPT 
1224:  BSF    F9D.5
....................    enable_interrupts(GLOBAL);       // ENABLE GLOBEL INTERRUPT 
1226:  MOVLW  C0
1228:  IORWF  FF2,F
....................    delay_ms(200); 
122A:  MOVLW  C8
122C:  MOVWF  xAD
122E:  CALL   09BC
....................    lcd_init();    // CALL FOR ALPHANUMERIC 20 X 4 LINE LCD INITIALIZATION 
1232:  BRA    0B0C
....................    output_high(LCD_BKLT);  // MAKE LCD BACKLIGHT ON 
1234:  MOVLW  F0
1236:  MOVWF  F94
1238:  BSF    F8B.2
....................    display_startup_message(); // SHOW STARTUP MESSAGE ON LCD DISPLAY 
123A:  BRA    0BAE
123C:  CLRF   19
123E:  BTFSC  FF2.7
1240:  BSF    19.7
1242:  BCF    FF2.7
....................    send_startup_message(); // SEND STARTUP MESSSAGE TO PC VIA UART 
1244:  CALL   01C6
1248:  BTFSC  19.7
124A:  BSF    FF2.7
....................    delay_ms(3000);      // DELAY TO KEEP STARTUP MESSAGE ON LCD 3000 = 3 SEC    
124C:  MOVLW  0C
124E:  MOVWF  xAC
1250:  MOVLW  FA
1252:  MOVWF  xAD
1254:  CALL   09BC
1258:  DECFSZ xAC,F
125A:  BRA    1250
....................    display_clear_line_all();  // EREASE STARTUP MESSAGE 
125C:  BRA    0CDA
....................    display_status_line1();   //  BRING STANDARD TEXT ON LCD 
125E:  BRA    0CE6
....................    display_status_line3();   //  BRING STANDARD TEXT ON LCD    
1260:  BRA    0D14
....................    display_relay_status();   // SHOW RELAY STATUS ON LCD 
1262:  RCALL  0D42
....................  
.................... /* 
....................    MAIN LOOP 
.................... */ 
....................    while(true) 
....................    { 
....................       if(b_relay_changed != 0)  // CHECK IF UART COMMAND RECEIVED 
1264:  MOVF   25,F
1266:  BZ    1280
....................       { 
....................          display_relay_status();    // UPDATE RELAY STATUS ON LCD 
1268:  RCALL  0D42
126A:  CLRF   19
126C:  BTFSC  FF2.7
126E:  BSF    19.7
1270:  BCF    FF2.7
....................          send_relay_status(b_relay_changed); //SEND RELAY STATUS TO PC 
1272:  MOVFF  25,D5
1276:  CALL   04A0
127A:  BTFSC  19.7
127C:  BSF    FF2.7
....................          b_relay_changed = 0; 
127E:  CLRF   25
....................       } 
....................       keyboard_routine();  // CHECK FOR ANY KEY PRESS 
1280:  BRA    0EBE
1282:  BRA    1264
....................    } 
.................... } 
....................  
1284:  SLEEP 
....................  
....................  
.................... //========================================= 
.................... /* 
.................... KEYBOARD ROUTINE 
.................... HERE ALL SWITCH STATUS ARE CHECKED SEQUENTIALLY 
.................... AT EACH SWITCH PRESS THE RELAY IS TOGGLED & THE STATUS IS DISPLAYED ON LCD AS WELL AS SEND TO PC VIA UART 
.................... */ 
....................  
.................... void keyboard_routine(void) 
.................... { 
....................    if(b_sw1 == 0) 
*
0EBE:  BTFSC  1A.0
0EC0:  BRA    0EF6
....................    { 
....................       output_toggle(RLY1); 
0EC2:  MOVLW  E8
0EC4:  MOVWF  F96
0EC6:  BTG    F8D.0
....................       output_high(LCD_BKLT); 
0EC8:  MOVLW  F0
0ECA:  MOVWF  F94
0ECC:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
0ECE:  RCALL  0D42
0ED0:  CLRF   19
0ED2:  BTFSC  FF2.7
0ED4:  BSF    19.7
0ED6:  BCF    FF2.7
....................       send_relay_status(1);   // Send new status on UART 
0ED8:  MOVLW  01
0EDA:  MOVWF  xD5
0EDC:  CALL   04A0
0EE0:  BTFSC  19.7
0EE2:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
0EE4:  MOVLW  1E
0EE6:  MOVWF  xAD
0EE8:  RCALL  09BC
....................       while(b_sw1 == 0) 
0EEA:  BTFSC  1A.0
0EEC:  BRA    0EF0
....................       {}               // wait for switch release 
0EEE:  BRA    0EEA
....................       delay_ms(30);  // Switch Press Debounse 
0EF0:  MOVLW  1E
0EF2:  MOVWF  xAD
0EF4:  RCALL  09BC
....................    } 
....................    if(b_sw2 == 0) 
0EF6:  BTFSC  1A.1
0EF8:  BRA    0F2E
....................    { 
....................       output_toggle(RLY2); 
0EFA:  MOVLW  00
0EFC:  MOVWF  F92
0EFE:  BTG    F89.5
....................       output_high(LCD_BKLT); 
0F00:  MOVLW  F0
0F02:  MOVWF  F94
0F04:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
0F06:  RCALL  0D42
0F08:  CLRF   19
0F0A:  BTFSC  FF2.7
0F0C:  BSF    19.7
0F0E:  BCF    FF2.7
....................       send_relay_status(2);   // Send new status on UART 
0F10:  MOVLW  02
0F12:  MOVWF  xD5
0F14:  CALL   04A0
0F18:  BTFSC  19.7
0F1A:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
0F1C:  MOVLW  1E
0F1E:  MOVWF  xAD
0F20:  RCALL  09BC
....................       while(b_sw2 == 0) 
0F22:  BTFSC  1A.1
0F24:  BRA    0F28
....................       {}               // wait for switch release 
0F26:  BRA    0F22
....................       delay_ms(30);  // Switch Press Debounse 
0F28:  MOVLW  1E
0F2A:  MOVWF  xAD
0F2C:  RCALL  09BC
....................    } 
....................    if(b_sw3 == 0) 
0F2E:  BTFSC  1A.2
0F30:  BRA    0F66
....................    { 
....................       output_toggle(RLY3); 
0F32:  MOVLW  00
0F34:  MOVWF  F92
0F36:  BTG    F89.4
....................       output_high(LCD_BKLT); 
0F38:  MOVLW  F0
0F3A:  MOVWF  F94
0F3C:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
0F3E:  RCALL  0D42
0F40:  CLRF   19
0F42:  BTFSC  FF2.7
0F44:  BSF    19.7
0F46:  BCF    FF2.7
....................       send_relay_status(3);   // Send new status on UART 
0F48:  MOVLW  03
0F4A:  MOVWF  xD5
0F4C:  CALL   04A0
0F50:  BTFSC  19.7
0F52:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
0F54:  MOVLW  1E
0F56:  MOVWF  xAD
0F58:  RCALL  09BC
....................       while(b_sw3 == 0) 
0F5A:  BTFSC  1A.2
0F5C:  BRA    0F60
....................       {}               // wait for switch release 
0F5E:  BRA    0F5A
....................       delay_ms(30);  // Switch Press Debounse 
0F60:  MOVLW  1E
0F62:  MOVWF  xAD
0F64:  RCALL  09BC
....................    } 
....................    if(b_sw4 == 0) 
0F66:  BTFSC  1A.3
0F68:  BRA    0F9E
....................    { 
....................       output_toggle(RLY4); 
0F6A:  MOVLW  00
0F6C:  MOVWF  F92
0F6E:  BTG    F89.3
....................       output_high(LCD_BKLT); 
0F70:  MOVLW  F0
0F72:  MOVWF  F94
0F74:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
0F76:  RCALL  0D42
0F78:  CLRF   19
0F7A:  BTFSC  FF2.7
0F7C:  BSF    19.7
0F7E:  BCF    FF2.7
....................       send_relay_status(4);   // Send new status on UART 
0F80:  MOVLW  04
0F82:  MOVWF  xD5
0F84:  CALL   04A0
0F88:  BTFSC  19.7
0F8A:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
0F8C:  MOVLW  1E
0F8E:  MOVWF  xAD
0F90:  RCALL  09BC
....................       while(b_sw4 == 0) 
0F92:  BTFSC  1A.3
0F94:  BRA    0F98
....................       {}               // wait for switch release 
0F96:  BRA    0F92
....................       delay_ms(30);  // Switch Press Debounse 
0F98:  MOVLW  1E
0F9A:  MOVWF  xAD
0F9C:  RCALL  09BC
....................    } 
....................    if(b_sw5 == 0) 
0F9E:  BTFSC  1A.4
0FA0:  BRA    0FD6
....................    { 
....................       output_toggle(RLY5); 
0FA2:  MOVLW  00
0FA4:  MOVWF  F92
0FA6:  BTG    F89.2
....................       output_high(LCD_BKLT); 
0FA8:  MOVLW  F0
0FAA:  MOVWF  F94
0FAC:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
0FAE:  RCALL  0D42
0FB0:  CLRF   19
0FB2:  BTFSC  FF2.7
0FB4:  BSF    19.7
0FB6:  BCF    FF2.7
....................       send_relay_status(5);   // Send new status on UART 
0FB8:  MOVLW  05
0FBA:  MOVWF  xD5
0FBC:  CALL   04A0
0FC0:  BTFSC  19.7
0FC2:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
0FC4:  MOVLW  1E
0FC6:  MOVWF  xAD
0FC8:  RCALL  09BC
....................       while(b_sw5 == 0) 
0FCA:  BTFSC  1A.4
0FCC:  BRA    0FD0
....................       {}               // wait for switch release 
0FCE:  BRA    0FCA
....................       delay_ms(30);  // Switch Press Debounse 
0FD0:  MOVLW  1E
0FD2:  MOVWF  xAD
0FD4:  RCALL  09BC
....................    } 
....................    if(b_sw6 == 0) 
0FD6:  BTFSC  1A.5
0FD8:  BRA    100E
....................    { 
....................       output_toggle(RLY6); 
0FDA:  MOVLW  00
0FDC:  MOVWF  F92
0FDE:  BTG    F89.1
....................       output_high(LCD_BKLT); 
0FE0:  MOVLW  F0
0FE2:  MOVWF  F94
0FE4:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
0FE6:  RCALL  0D42
0FE8:  CLRF   19
0FEA:  BTFSC  FF2.7
0FEC:  BSF    19.7
0FEE:  BCF    FF2.7
....................       send_relay_status(6);   // Send new status on UART 
0FF0:  MOVLW  06
0FF2:  MOVWF  xD5
0FF4:  CALL   04A0
0FF8:  BTFSC  19.7
0FFA:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
0FFC:  MOVLW  1E
0FFE:  MOVWF  xAD
1000:  RCALL  09BC
....................       while(b_sw6 == 0) 
1002:  BTFSC  1A.5
1004:  BRA    1008
....................       {}               // wait for switch release 
1006:  BRA    1002
....................       delay_ms(30);  // Switch Press Debounse 
1008:  MOVLW  1E
100A:  MOVWF  xAD
100C:  RCALL  09BC
....................    } 
....................    if(b_sw7 == 0) 
100E:  BTFSC  1A.6
1010:  BRA    1046
....................    { 
....................       output_toggle(RLY7); 
1012:  MOVLW  00
1014:  MOVWF  F92
1016:  BTG    F89.0
....................       output_high(LCD_BKLT); 
1018:  MOVLW  F0
101A:  MOVWF  F94
101C:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
101E:  RCALL  0D42
1020:  CLRF   19
1022:  BTFSC  FF2.7
1024:  BSF    19.7
1026:  BCF    FF2.7
....................       send_relay_status(7);   // Send new status on UART 
1028:  MOVLW  07
102A:  MOVWF  xD5
102C:  CALL   04A0
1030:  BTFSC  19.7
1032:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
1034:  MOVLW  1E
1036:  MOVWF  xAD
1038:  RCALL  09BC
....................       while(b_sw7 == 0) 
103A:  BTFSC  1A.6
103C:  BRA    1040
....................       {}               // wait for switch release 
103E:  BRA    103A
....................       delay_ms(30);  // Switch Press Debounse 
1040:  MOVLW  1E
1042:  MOVWF  xAD
1044:  RCALL  09BC
....................    } 
....................    if(b_sw8 == 0) 
1046:  BTFSC  1A.7
1048:  BRA    107E
....................    { 
....................       output_toggle(RLY8); 
104A:  MOVLW  E8
104C:  MOVWF  F96
104E:  BTG    F8D.1
....................       output_high(LCD_BKLT); 
1050:  MOVLW  F0
1052:  MOVWF  F94
1054:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
1056:  RCALL  0D42
1058:  CLRF   19
105A:  BTFSC  FF2.7
105C:  BSF    19.7
105E:  BCF    FF2.7
....................       send_relay_status(8);   // Send new status on UART 
1060:  MOVLW  08
1062:  MOVWF  xD5
1064:  CALL   04A0
1068:  BTFSC  19.7
106A:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
106C:  MOVLW  1E
106E:  MOVWF  xAD
1070:  RCALL  09BC
....................       while(b_sw8 == 0) 
1072:  BTFSC  1A.7
1074:  BRA    1078
....................       {}               // wait for switch release 
1076:  BRA    1072
....................       delay_ms(30);  // Switch Press Debounse 
1078:  MOVLW  1E
107A:  MOVWF  xAD
107C:  RCALL  09BC
....................    } 
....................    if(b_sw9 == 0) 
107E:  BTFSC  1B.0
1080:  BRA    10B6
....................    { 
....................       output_toggle(RLY9); 
1082:  MOVLW  E8
1084:  MOVWF  F96
1086:  BTG    F8D.2
....................       output_high(LCD_BKLT); 
1088:  MOVLW  F0
108A:  MOVWF  F94
108C:  BSF    F8B.2
....................       display_relay_status(); // Update status on LCD 
108E:  RCALL  0D42
1090:  CLRF   19
1092:  BTFSC  FF2.7
1094:  BSF    19.7
1096:  BCF    FF2.7
....................       send_relay_status(9);   // Send new status on UART 
1098:  MOVLW  09
109A:  MOVWF  xD5
109C:  CALL   04A0
10A0:  BTFSC  19.7
10A2:  BSF    FF2.7
....................       delay_ms(30);  // Switch Press Debounse 
10A4:  MOVLW  1E
10A6:  MOVWF  xAD
10A8:  RCALL  09BC
....................       while(b_sw9 == 0) 
10AA:  BTFSC  1B.0
10AC:  BRA    10B0
....................       {}               // wait for switch release 
10AE:  BRA    10AA
....................       delay_ms(30);  // Switch Press Debounse 
10B0:  MOVLW  1E
10B2:  MOVWF  xAD
10B4:  RCALL  09BC
....................    } 
10B6:  GOTO   1282 (RETURN)
....................     
.................... } 
....................  
.................... //================================================ 
.................... /* 
....................    IN BELOW ROUTINES ALL RELAY STATUS ARE CHECKED & AS PER STATUS MESSAGES ARE SENT TO PC VIA UART 
.................... */ 
.................... void report_relay_states(void) { 
....................    for (int i = 0; i < 9; i++) { 
*
058C:  CLRF   xD3
058E:  MOVF   xD3,W
0590:  SUBLW  08
0592:  BNC   05A2
....................       send_relay_status(i+1); 
0594:  MOVLW  01
0596:  ADDWF  xD3,W
0598:  MOVWF  xD4
059A:  MOVWF  xD5
059C:  RCALL  04A0
059E:  INCF   xD3,F
05A0:  BRA    058E
....................    } 
05A2:  GOTO   0712 (RETURN)
.................... } 
....................  
.................... void send_relay_status(unsigned char rel) { 
*
04A0:  CLRF   xD6
....................    unsigned char state = 0; 
....................    switch (rel) { 
04A2:  MOVF   xD5,W
04A4:  XORLW  01
04A6:  BZ    04CA
04A8:  XORLW  03
04AA:  BZ    04D2
04AC:  XORLW  01
04AE:  BZ    04DA
04B0:  XORLW  07
04B2:  BZ    04E2
04B4:  XORLW  01
04B6:  BZ    04EA
04B8:  XORLW  03
04BA:  BZ    04F2
04BC:  XORLW  01
04BE:  BZ    04FA
04C0:  XORLW  0F
04C2:  BZ    0502
04C4:  XORLW  01
04C6:  BZ    050A
04C8:  BRA    0512
....................       case 1: 
....................          state = input_state(RLY1); 
04CA:  CLRF   xD6
04CC:  BTFSC  F84.0
04CE:  INCF   xD6,F
....................          break; 
04D0:  BRA    0514
....................       case 2: 
....................          state = input_state(RLY2); 
04D2:  CLRF   xD6
04D4:  BTFSC  F80.5
04D6:  INCF   xD6,F
....................          break; 
04D8:  BRA    0514
....................       case 3: 
....................          state = input_state(RLY3); 
04DA:  CLRF   xD6
04DC:  BTFSC  F80.4
04DE:  INCF   xD6,F
....................          break; 
04E0:  BRA    0514
....................       case 4: 
....................          state = input_state(RLY4); 
04E2:  CLRF   xD6
04E4:  BTFSC  F80.3
04E6:  INCF   xD6,F
....................          break; 
04E8:  BRA    0514
....................       case 5: 
....................          state = input_state(RLY5); 
04EA:  CLRF   xD6
04EC:  BTFSC  F80.2
04EE:  INCF   xD6,F
....................          break; 
04F0:  BRA    0514
....................       case 6: 
....................          state = input_state(RLY6); 
04F2:  CLRF   xD6
04F4:  BTFSC  F80.1
04F6:  INCF   xD6,F
....................          break; 
04F8:  BRA    0514
....................       case 7: 
....................          state = input_state(RLY7); 
04FA:  CLRF   xD6
04FC:  BTFSC  F80.0
04FE:  INCF   xD6,F
....................          break; 
0500:  BRA    0514
....................       case 8: 
....................          state = input_state(RLY8); 
0502:  CLRF   xD6
0504:  BTFSC  F84.1
0506:  INCF   xD6,F
....................          break; 
0508:  BRA    0514
....................       case 9: 
....................          state = input_state(RLY9); 
050A:  CLRF   xD6
050C:  BTFSC  F84.2
050E:  INCF   xD6,F
....................          break; 
0510:  BRA    0514
....................       default: 
....................          return; 
0512:  BRA    058A
....................          break; 
....................    } 
....................    char str[20]; 
....................    if (state) 
0514:  MOVF   xD6,F
0516:  BZ    0546
....................       sprintf(str, "RELAY%d SWITCHED ON", rel); 
0518:  CLRF   33
051A:  MOVLW  D7
051C:  MOVWF  32
051E:  MOVLW  80
0520:  MOVWF  FF6
0522:  MOVLW  07
0524:  MOVWF  FF7
0526:  MOVLW  05
0528:  MOVWF  xEB
052A:  RCALL  038A
052C:  MOVFF  D5,EB
0530:  MOVLW  18
0532:  MOVWF  xEC
0534:  RCALL  03D0
0536:  MOVLW  87
0538:  MOVWF  FF6
053A:  MOVLW  07
053C:  MOVWF  FF7
053E:  MOVLW  0C
0540:  MOVWF  xEB
0542:  RCALL  038A
0544:  BRA    0572
....................    else 
....................       sprintf(str, "RELAY%d SWITCHED OFF", rel); 
0546:  CLRF   33
0548:  MOVLW  D7
054A:  MOVWF  32
054C:  MOVLW  94
054E:  MOVWF  FF6
0550:  MOVLW  07
0552:  MOVWF  FF7
0554:  MOVLW  05
0556:  MOVWF  xEB
0558:  RCALL  038A
055A:  MOVFF  D5,EB
055E:  MOVLW  18
0560:  MOVWF  xEC
0562:  RCALL  03D0
0564:  MOVLW  9B
0566:  MOVWF  FF6
0568:  MOVLW  07
056A:  MOVWF  FF7
056C:  MOVLW  0D
056E:  MOVWF  xEB
0570:  RCALL  038A
....................    puts(str); 
0572:  CLRF   FEA
0574:  MOVLW  D7
0576:  MOVWF  FE9
0578:  RCALL  047A
057A:  MOVLW  0D
057C:  BTFSS  F9E.4
057E:  BRA    057C
0580:  MOVWF  FAD
0582:  MOVLW  0A
0584:  BTFSS  F9E.4
0586:  BRA    0584
0588:  MOVWF  FAD
058A:  RETURN 0
.................... } 
....................  
....................  
.................... //=================================================================== 
.................... /* 
.................... CHACK DATA 
.................... THIS ROUTINE IS CALLED AS SOON AS ANY COMMAND IS RECEIVED FROM INTERRUPT ROUTINE 
.................... IN THIS ROUTIN THE COMMAND FROM SERIAL BUFFER IS COMPAIRED AND AS PER THAT THE RESPACTIVE RELAY PORT PIN STATUS GETS ALTERED 
.................... */ 
.................... int check_data(void) 
.................... { 
....................    int c_buff_temp; 
....................    char stateCmp[] = "STATE"; 
*
05A6:  MOVLW  53
05A8:  MOVWF  xCD
05AA:  MOVLW  54
05AC:  MOVWF  xCE
05AE:  MOVLW  41
05B0:  MOVWF  xCF
05B2:  MOVLW  54
05B4:  MOVWF  xD0
05B6:  MOVLW  45
05B8:  MOVWF  xD1
05BA:  CLRF   xD2
....................    if(c_serial_buffer[0] == 'R') 
05BC:  MOVF   1D,W
05BE:  SUBLW  52
05C0:  BTFSS  FD8.2
05C2:  BRA    06E8
....................    {    
....................       if(c_serial_buffer[1] == 'L') 
05C4:  MOVF   1E,W
05C6:  SUBLW  4C
05C8:  BTFSS  FD8.2
05CA:  BRA    06E6
....................       { 
....................          if(c_serial_buffer[2] == 'Y') 
05CC:  MOVF   1F,W
05CE:  SUBLW  59
05D0:  BTFSS  FD8.2
05D2:  BRA    06E6
....................          { 
....................             if(c_serial_buffer[4] == 'O') 
05D4:  MOVF   21,W
05D6:  SUBLW  4F
05D8:  BTFSS  FD8.2
05DA:  BRA    06E0
....................             { 
....................                c_buff_temp = c_serial_buffer[3] - 48; // MAKING ASCII TO DECIMAL NO. 
05DC:  MOVLW  30
05DE:  SUBWF  20,W
05E0:  MOVWF  xCC
....................                output_high(LCD_BKLT);     // MAKE DISPLAY BACKLIGHT ON 
05E2:  MOVLW  F0
05E4:  MOVWF  F94
05E6:  BSF    F8B.2
....................                switch(c_buff_temp) 
05E8:  MOVLW  01
05EA:  SUBWF  xCC,W
05EC:  ADDLW  F7
05EE:  BTFSC  FD8.0
05F0:  BRA    06E0
05F2:  ADDLW  09
05F4:  GOTO   071A
....................                { 
....................                   case 1: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
05F8:  MOVF   22,W
05FA:  SUBLW  4E
05FC:  BNZ   0604
....................                      { 
....................                         output_high(RLY1); 
05FE:  MOVLW  E8
0600:  MOVWF  F96
0602:  BSF    F8D.0
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
0604:  MOVF   22,W
0606:  SUBLW  46
0608:  BNZ   0610
....................                      { 
....................                         output_low(RLY1); 
060A:  MOVLW  E8
060C:  MOVWF  F96
060E:  BCF    F8D.0
....................                      } 
....................                   } 
....................                   break; 
0610:  BRA    06E0
....................                    
....................                   case 2: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
0612:  MOVF   22,W
0614:  SUBLW  4E
0616:  BNZ   061E
....................                      { 
....................                         output_high(RLY2); 
0618:  MOVLW  00
061A:  MOVWF  F92
061C:  BSF    F89.5
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
061E:  MOVF   22,W
0620:  SUBLW  46
0622:  BNZ   062A
....................                      { 
....................                         output_low(RLY2); 
0624:  MOVLW  00
0626:  MOVWF  F92
0628:  BCF    F89.5
....................                      } 
....................                   } 
....................                   break; 
062A:  BRA    06E0
....................                    
....................                   case 3: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
062C:  MOVF   22,W
062E:  SUBLW  4E
0630:  BNZ   0638
....................                      { 
....................                         output_high(RLY3); 
0632:  MOVLW  00
0634:  MOVWF  F92
0636:  BSF    F89.4
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
0638:  MOVF   22,W
063A:  SUBLW  46
063C:  BNZ   0644
....................                      { 
....................                         output_low(RLY3); 
063E:  MOVLW  00
0640:  MOVWF  F92
0642:  BCF    F89.4
....................                      } 
....................                   } 
....................                   break; 
0644:  BRA    06E0
....................                    
....................                   case 4: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
0646:  MOVF   22,W
0648:  SUBLW  4E
064A:  BNZ   0652
....................                      { 
....................                         output_high(RLY4); 
064C:  MOVLW  00
064E:  MOVWF  F92
0650:  BSF    F89.3
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
0652:  MOVF   22,W
0654:  SUBLW  46
0656:  BNZ   065E
....................                      { 
....................                         output_low(RLY4); 
0658:  MOVLW  00
065A:  MOVWF  F92
065C:  BCF    F89.3
....................                      } 
....................                   } 
....................                   break; 
065E:  BRA    06E0
....................                    
....................                   case 5: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
0660:  MOVF   22,W
0662:  SUBLW  4E
0664:  BNZ   066C
....................                      { 
....................                         output_high(RLY5); 
0666:  MOVLW  00
0668:  MOVWF  F92
066A:  BSF    F89.2
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
066C:  MOVF   22,W
066E:  SUBLW  46
0670:  BNZ   0678
....................                      { 
....................                         output_low(RLY5); 
0672:  MOVLW  00
0674:  MOVWF  F92
0676:  BCF    F89.2
....................                      } 
....................                   } 
....................                   break; 
0678:  BRA    06E0
....................                    
....................                   case 6: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
067A:  MOVF   22,W
067C:  SUBLW  4E
067E:  BNZ   0686
....................                      { 
....................                         output_high(RLY6); 
0680:  MOVLW  00
0682:  MOVWF  F92
0684:  BSF    F89.1
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
0686:  MOVF   22,W
0688:  SUBLW  46
068A:  BNZ   0692
....................                      { 
....................                         output_low(RLY6); 
068C:  MOVLW  00
068E:  MOVWF  F92
0690:  BCF    F89.1
....................                      } 
....................                   } 
....................                   break; 
0692:  BRA    06E0
....................                    
....................                   case 7: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
0694:  MOVF   22,W
0696:  SUBLW  4E
0698:  BNZ   06A0
....................                      { 
....................                         output_high(RLY7); 
069A:  MOVLW  00
069C:  MOVWF  F92
069E:  BSF    F89.0
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
06A0:  MOVF   22,W
06A2:  SUBLW  46
06A4:  BNZ   06AC
....................                      { 
....................                         output_low(RLY7); 
06A6:  MOVLW  00
06A8:  MOVWF  F92
06AA:  BCF    F89.0
....................                      } 
....................                   } 
....................                   break; 
06AC:  BRA    06E0
....................                    
....................                   case 8: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
06AE:  MOVF   22,W
06B0:  SUBLW  4E
06B2:  BNZ   06BA
....................                      { 
....................                         output_high(RLY8); 
06B4:  MOVLW  E8
06B6:  MOVWF  F96
06B8:  BSF    F8D.1
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
06BA:  MOVF   22,W
06BC:  SUBLW  46
06BE:  BNZ   06C6
....................                      { 
....................                         output_low(RLY8); 
06C0:  MOVLW  E8
06C2:  MOVWF  F96
06C4:  BCF    F8D.1
....................                      } 
....................                   } 
....................                   break; 
06C6:  BRA    06E0
....................                    
....................                   case 9: 
....................                   { 
....................                      if(c_serial_buffer[5] == 'N') 
06C8:  MOVF   22,W
06CA:  SUBLW  4E
06CC:  BNZ   06D4
....................                      { 
....................                         output_high(RLY9); 
06CE:  MOVLW  E8
06D0:  MOVWF  F96
06D2:  BSF    F8D.2
....................                      } 
....................                      if(c_serial_buffer[5] == 'F') 
06D4:  MOVF   22,W
06D6:  SUBLW  46
06D8:  BNZ   06E0
....................                      { 
....................                         output_low(RLY9); 
06DA:  MOVLW  E8
06DC:  MOVWF  F96
06DE:  BCF    F8D.2
....................                      } 
....................                   } 
....................                   break;                  
....................                } 
....................             } 
....................             return c_buff_temp; 
06E0:  MOVFF  CC,01
06E4:  BRA    0716
....................          } 
....................       } 
....................    } 
06E6:  BRA    0712
....................    else if (c_serial_buffer[0] == 'H') { 
06E8:  MOVF   1D,W
06EA:  SUBLW  48
06EC:  BNZ   06F2
....................       send_startup_message(); 
06EE:  RCALL  01C6
....................    } 
06F0:  BRA    0712
....................    else if (strstr(c_serial_buffer, stateCmp) != NULL) { 
06F2:  CLRF   xD4
06F4:  MOVLW  1D
06F6:  MOVWF  xD3
06F8:  CLRF   xD6
06FA:  MOVLW  CD
06FC:  MOVWF  xD5
06FE:  BRA    02E6
0700:  MOVFF  02,D4
0704:  MOVFF  01,D3
0708:  MOVF   xD3,F
070A:  BNZ   0710
070C:  MOVF   xD4,F
070E:  BZ    0712
....................       report_relay_states(); 
0710:  BRA    058C
....................    } 
....................    return 0; 
0712:  MOVLW  00
0714:  MOVWF  01
0716:  GOTO   0760 (RETURN)
.................... } 
....................  
....................  
.................... //================================================================= 
....................  
....................  
.................... void lcd_init(void) 
.................... { 
....................    put_lcd_data_h(0x20);      //Function Set: 4-bit, 1 Line, 5x7 Dots 
*
0B0C:  MOVLW  20
0B0E:  MOVWF  xB0
0B10:  RCALL  09E4
....................    lcd_cmd();  
0B12:  RCALL  0A56
....................    delay_ms(150);  
0B14:  MOVLW  96
0B16:  MOVWF  xAD
0B18:  RCALL  09BC
....................     
....................    put_lcd_data_h(0x20);      //Function Set: 4-bit, 1 Line, 5x7 Dots 
0B1A:  MOVLW  20
0B1C:  MOVWF  xB0
0B1E:  RCALL  09E4
....................    lcd_cmd();  
0B20:  RCALL  0A56
....................    delay_ms(150);  
0B22:  MOVLW  96
0B24:  MOVWF  xAD
0B26:  RCALL  09BC
....................     
....................    put_lcd_data_h(0x20);      //Function Set: 4-bit, 1 Line, 5x7 Dots 
0B28:  MOVLW  20
0B2A:  MOVWF  xB0
0B2C:  RCALL  09E4
....................    lcd_cmd();  
0B2E:  RCALL  0A56
....................    delay_ms(150);  
0B30:  MOVLW  96
0B32:  MOVWF  xAD
0B34:  RCALL  09BC
....................     
....................    send_lcd_command(0x28);   //Function Set: 4-bit, 2 Line, 5x7 Dots 
0B36:  MOVLW  28
0B38:  MOVWF  xAE
0B3A:  RCALL  0AFA
....................    delay_ms(100);     
0B3C:  MOVLW  64
0B3E:  MOVWF  xAD
0B40:  RCALL  09BC
....................     
....................    send_lcd_command(0x0C);   //   Display on Cursor off 
0B42:  MOVLW  0C
0B44:  MOVWF  xAE
0B46:  RCALL  0AFA
....................    delay_ms(100);    
0B48:  MOVLW  64
0B4A:  MOVWF  xAD
0B4C:  RCALL  09BC
....................     
....................    send_lcd_command(0x06);     //    Entry Mode Increment cursor position 
0B4E:  MOVLW  06
0B50:  MOVWF  xAE
0B52:  RCALL  0AFA
....................    delay_ms(100);  
0B54:  MOVLW  64
0B56:  MOVWF  xAD
0B58:  RCALL  09BC
....................        
....................    send_lcd_command(0x01);      //Clear Display (also clear DDRAM content) 
0B5A:  MOVLW  01
0B5C:  MOVWF  xAE
0B5E:  RCALL  0AFA
....................    delay_ms(100);     
0B60:  MOVLW  64
0B62:  MOVWF  xAD
0B64:  RCALL  09BC
0B66:  GOTO   1234 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void send_lcd_command (unsigned char c_data) // SEND LCD COMMAND NIBBLE BY NIBBLE AS FOR 4 BIT COMMUNICATION 
.................... { 
....................     put_lcd_data_h(c_data); 
*
0AFA:  MOVFF  AE,B0
0AFE:  RCALL  09E4
....................     lcd_cmd(); 
0B00:  RCALL  0A56
....................     put_lcd_data_l(c_data); 
0B02:  MOVFF  AE,B0
0B06:  RCALL  0A88
....................     lcd_cmd(); 
0B08:  RCALL  0A56
0B0A:  RETURN 0
.................... } 
....................  
.................... void send_lcd_data (unsigned char c_data) // SEND LCD DATA NIBBLE BY NIBBLE AS FOR 4 BIT COMMUNICATION 
.................... { 
....................     put_lcd_data_h(c_data); 
*
0B9C:  MOVFF  AF,B0
0BA0:  RCALL  09E4
....................     lcd_data(); 
0BA2:  RCALL  0B6A
....................     put_lcd_data_l(c_data); 
0BA4:  MOVFF  AF,B0
0BA8:  RCALL  0A88
....................     lcd_data(); 
0BAA:  RCALL  0B6A
0BAC:  RETURN 0
.................... } 
....................  
.................... /* 
....................    LCD DATA 
....................    PROVIDE PULSE ON ENABLE BY KEEPING RS(REGISTOR SELECT) FOR DATA  
.................... */ 
.................... void lcd_data (void) 
.................... { 
....................    output_high(LCD_RS); 
*
0B6A:  MOVLW  F9
0B6C:  MOVWF  F95
0B6E:  BSF    F8C.1
....................    output_low(LCD_EN); 
0B70:  MOVLW  F0
0B72:  MOVWF  F94
0B74:  BCF    F8B.3
....................    delay_us(100);  
0B76:  MOVLW  85
0B78:  MOVWF  00
0B7A:  DECFSZ 00,F
0B7C:  BRA    0B7A
....................    output_high(LCD_EN); 
0B7E:  MOVLW  F0
0B80:  MOVWF  F94
0B82:  BSF    F8B.3
....................    delay_us(100);    
0B84:  MOVLW  85
0B86:  MOVWF  00
0B88:  DECFSZ 00,F
0B8A:  BRA    0B88
....................    output_low(LCD_EN);   
0B8C:  MOVLW  F0
0B8E:  MOVWF  F94
0B90:  BCF    F8B.3
....................    delay_us(100);   // every cycle will need delay 
0B92:  MOVLW  85
0B94:  MOVWF  00
0B96:  DECFSZ 00,F
0B98:  BRA    0B96
0B9A:  RETURN 0
.................... } 
....................  
.................... /* 
....................    LCD COMMAND 
....................    PROVIDE PULSE ON ENABLE BY KEEPING RS(REGISTOR SELECT) FOR COMMAND  
.................... */ 
.................... void lcd_cmd (void) 
.................... { 
....................    output_low(LCD_RS); 
*
0A56:  MOVLW  F9
0A58:  MOVWF  F95
0A5A:  BCF    F8C.1
....................    output_low(LCD_EN); 
0A5C:  MOVLW  F0
0A5E:  MOVWF  F94
0A60:  BCF    F8B.3
....................    delay_us(100);  
0A62:  MOVLW  85
0A64:  MOVWF  00
0A66:  DECFSZ 00,F
0A68:  BRA    0A66
....................    output_high(LCD_EN); 
0A6A:  MOVLW  F0
0A6C:  MOVWF  F94
0A6E:  BSF    F8B.3
....................    delay_us(100);    
0A70:  MOVLW  85
0A72:  MOVWF  00
0A74:  DECFSZ 00,F
0A76:  BRA    0A74
....................    output_low(LCD_EN);   
0A78:  MOVLW  F0
0A7A:  MOVWF  F94
0A7C:  BCF    F8B.3
....................    delay_us(100);   // every cycle will need delay 
0A7E:  MOVLW  85
0A80:  MOVWF  00
0A82:  DECFSZ 00,F
0A84:  BRA    0A82
0A86:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... //==================================================================== 
.................... /*   
....................    put_lcd_data_h 
....................    RE ARRANGE LCD DATA & PUT LOWER NIBBBLE ON DATA LINES 
....................    AS THE LCD DATA BUS IS CONNECED TO RANDOM AVAILABEL PORT PINS OF THE MCU 
....................    IT IS REQUIRED TO RE ARRANGE THE DATA WORD AS PER CONNECTED PORT PIN TO DATA LINES 
....................    AS THE LCD IS CONFIGURED FOR 4 BIT COMMUNICATION, THIS ROUTINE MAKES HIGHER NIBBLE AVAILABLE ON LCD PORT 
.................... */ 
.................... //==================================================================== 
.................... void put_lcd_data_h (unsigned char c_lcd_data) 
.................... { 
.................... unsigned char c_data_copy; 
....................  
....................    c_data_copy = c_lcd_data; 
*
09E4:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x10;   // MASK ALL BITS & KEEP ONLY 5TH BIT 
09E8:  MOVLW  10
09EA:  ANDWF  xB1,F
....................    if(c_data_copy >= 1)    // CHECK IF 4TH BIT IS 1  
09EC:  MOVF   xB1,W
09EE:  SUBLW  00
09F0:  BC    09FA
....................    { 
....................       output_high(D4);   // SET LCD DATA LINE D4 HIGH  
09F2:  MOVLW  F0
09F4:  MOVWF  F94
09F6:  BSF    F8B.1
....................    } 
09F8:  BRA    0A00
....................    else 
....................    { 
....................       output_low(D4);     // SET LCD DATA LINE D4 LOW 
09FA:  MOVLW  F0
09FC:  MOVWF  F94
09FE:  BCF    F8B.1
....................    } 
....................     
....................    c_data_copy = c_lcd_data; 
0A00:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x20;   // MASK ALL BITS & KEEP ONLY 6TH BIT 
0A04:  MOVLW  20
0A06:  ANDWF  xB1,F
....................    if(c_data_copy >= 1) // CHECK IF BIT IS 1 
0A08:  MOVF   xB1,W
0A0A:  SUBLW  00
0A0C:  BC    0A16
....................    { 
....................       output_high(D5);   // SET LCD DATA LINE D5 HIGH  
0A0E:  MOVLW  F0
0A10:  MOVWF  F94
0A12:  BSF    F8B.0
....................    } 
0A14:  BRA    0A1C
....................    else 
....................    { 
....................       output_low(D5);     // SET LCD DATA LINE D5 LOW 
0A16:  MOVLW  F0
0A18:  MOVWF  F94
0A1A:  BCF    F8B.0
....................    } 
....................     
....................    c_data_copy = c_lcd_data; 
0A1C:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x40;   // MASK ALL BITS & KEEP ONLY 7TH BIT 
0A20:  MOVLW  40
0A22:  ANDWF  xB1,F
....................    if(c_data_copy >= 1) // CHECK IF BIT IS 1 
0A24:  MOVF   xB1,W
0A26:  SUBLW  00
0A28:  BC    0A32
....................    { 
....................       output_high(D6);   // SET LCD DATA LINE D6 HIGH  
0A2A:  MOVLW  00
0A2C:  MOVWF  F92
0A2E:  BSF    F89.6
....................    } 
0A30:  BRA    0A38
....................    else 
....................    { 
....................       output_low(D6);    // SET LCD DATA LINE D6 LOW 
0A32:  MOVLW  00
0A34:  MOVWF  F92
0A36:  BCF    F89.6
....................    } 
....................     
....................    c_data_copy = c_lcd_data; 
0A38:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x80;   // MASK ALL BITS & KEEP ONLY 8TH BIT 
0A3C:  MOVLW  80
0A3E:  ANDWF  xB1,F
....................    if(c_data_copy >= 1) // CHECK IF BIT IS 1 
0A40:  MOVF   xB1,W
0A42:  SUBLW  00
0A44:  BC    0A4E
....................    { 
....................       output_high(D7);   // SET LCD DATA LINE D7 HIGH     
0A46:  MOVLW  00
0A48:  MOVWF  F92
0A4A:  BSF    F89.7
....................    } 
0A4C:  BRA    0A54
....................    else 
....................    { 
....................       output_low(D7);    // SET LCD DATA LINE D7 LOW  
0A4E:  MOVLW  00
0A50:  MOVWF  F92
0A52:  BCF    F89.7
....................    } 
0A54:  RETURN 0
....................  
.................... } 
....................  
.................... //==================================================================== 
.................... /*   
....................    put_lcd_data_l 
....................    RE ARRANGE LCD DATA & PUT LOWER NIBBBLE ON DATA LINES 
....................    AS THE LCD DATA BUS IS CONNECED TO RANDOM AVAILABEL PORT PINS OF THE MCU 
....................    IT IS REQUIRED TO RE ARRANGE THE DATA WORD AS PER CONNECTED PORT PIN TO DATA LINES 
....................    AS THE LCD IS CONFIGURED FOR 4 BIT COMMUNICATION, THIS ROUTINE MAKES LOWER NIBBLE AVAILABLE ON LCD PORT 
.................... */ 
.................... //==================================================================== 
.................... void put_lcd_data_l (unsigned char c_lcd_data) 
.................... { 
.................... unsigned char c_data_copy; 
....................  
....................    c_data_copy = c_lcd_data; 
*
0A88:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x01;   // MASK ALL BITS & KEEP ONLY 1ST BIT 
0A8C:  MOVLW  01
0A8E:  ANDWF  xB1,F
....................    if(c_data_copy >= 1) // CHECK IF BIT IS 1 
0A90:  MOVF   xB1,W
0A92:  SUBLW  00
0A94:  BC    0A9E
....................    { 
....................       output_high(D4);   // SET LCD DATA LINE D4 HIGH    
0A96:  MOVLW  F0
0A98:  MOVWF  F94
0A9A:  BSF    F8B.1
....................    } 
0A9C:  BRA    0AA4
....................    else 
....................    { 
....................       output_low(D4);    // SET LCD DATA LINE D4 LOW  
0A9E:  MOVLW  F0
0AA0:  MOVWF  F94
0AA2:  BCF    F8B.1
....................    } 
....................     
....................    c_data_copy = c_lcd_data; 
0AA4:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x02;   // MASK ALL BITS & KEEP ONLY 2ND BIT 
0AA8:  MOVLW  02
0AAA:  ANDWF  xB1,F
....................    if(c_data_copy >= 1) // CHECK IF BIT IS 1 
0AAC:  MOVF   xB1,W
0AAE:  SUBLW  00
0AB0:  BC    0ABA
....................    { 
....................       output_high(D5);   // SET LCD DATA LINE D5 HIGH      
0AB2:  MOVLW  F0
0AB4:  MOVWF  F94
0AB6:  BSF    F8B.0
....................    } 
0AB8:  BRA    0AC0
....................    else 
....................    { 
....................       output_low(D5);    // SET LCD DATA LINE D5 LOW   
0ABA:  MOVLW  F0
0ABC:  MOVWF  F94
0ABE:  BCF    F8B.0
....................    } 
....................     
....................    c_data_copy = c_lcd_data; 
0AC0:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x04;   // MASK ALL BITS & KEEP ONLY 3RD BIT 
0AC4:  MOVLW  04
0AC6:  ANDWF  xB1,F
....................    if(c_data_copy >= 1) // CHECK IF BIT IS 1 
0AC8:  MOVF   xB1,W
0ACA:  SUBLW  00
0ACC:  BC    0AD6
....................    { 
....................       output_high(D6);   // SET LCD DATA LINE D6 HIGH      
0ACE:  MOVLW  00
0AD0:  MOVWF  F92
0AD2:  BSF    F89.6
....................    } 
0AD4:  BRA    0ADC
....................    else 
....................    { 
....................       output_low(D6);    // SET LCD DATA LINE D6 LOW   
0AD6:  MOVLW  00
0AD8:  MOVWF  F92
0ADA:  BCF    F89.6
....................    } 
....................     
....................    c_data_copy = c_lcd_data; 
0ADC:  MOVFF  B0,B1
....................    c_data_copy = c_data_copy & 0x08;   // MASK ALL BITS & KEEP ONLY 4TH BIT 
0AE0:  MOVLW  08
0AE2:  ANDWF  xB1,F
....................    if(c_data_copy >= 1) // CHECK IF BIT IS 1 
0AE4:  MOVF   xB1,W
0AE6:  SUBLW  00
0AE8:  BC    0AF2
....................    { 
....................       output_high(D7);   // SET LCD DATA LINE D7 HIGH      
0AEA:  MOVLW  00
0AEC:  MOVWF  F92
0AEE:  BSF    F89.7
....................    } 
0AF0:  BRA    0AF8
....................    else 
....................    { 
....................       output_low(D7);    // SET LCD DATA LINE D7 LOW   
0AF2:  MOVLW  00
0AF4:  MOVWF  F92
0AF6:  BCF    F89.7
....................    } 
0AF8:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
.................... // CLEAR LCD LINE 1 BY SENDING BLANK SPACE TO ALL CHARACTORS 
.................... void display_clear_line_1(void) 
*
0C5A:  CLRF   xAD
.................... {    
.................... unsigned char k; 
.................... unsigned char z = 0; 
....................    send_lcd_command(lcd_line1); 
0C5C:  MOVLW  80
0C5E:  MOVWF  xAE
0C60:  RCALL  0AFA
....................     
....................    for (k = 20; k > 0 ; k--)  // 
0C62:  MOVLW  14
0C64:  MOVWF  xAC
0C66:  MOVF   xAC,F
0C68:  BZ    0C76
....................    { 
....................       send_lcd_data(' '); 
0C6A:  MOVLW  20
0C6C:  MOVWF  xAF
0C6E:  RCALL  0B9C
....................       z++; 
0C70:  INCF   xAD,F
0C72:  DECF   xAC,F
0C74:  BRA    0C66
....................    } 
0C76:  GOTO   0CDC (RETURN)
.................... } 
.................... //==================== 
....................  
.................... // CLEAR LCD LINE 2 BY SENDING BLANK SPACE TO ALL CHARACTORS 
.................... void display_clear_line_2(void) 
0C7A:  CLRF   xAD
.................... {    
.................... unsigned char k; 
.................... unsigned char z = 0; 
....................    send_lcd_command(lcd_line2); 
0C7C:  MOVLW  C0
0C7E:  MOVWF  xAE
0C80:  RCALL  0AFA
....................     
....................    for (k = 20; k > 0 ; k--)  // 
0C82:  MOVLW  14
0C84:  MOVWF  xAC
0C86:  MOVF   xAC,F
0C88:  BZ    0C96
....................    { 
....................       send_lcd_data(' '); 
0C8A:  MOVLW  20
0C8C:  MOVWF  xAF
0C8E:  RCALL  0B9C
....................       z++; 
0C90:  INCF   xAD,F
0C92:  DECF   xAC,F
0C94:  BRA    0C86
....................    } 
0C96:  GOTO   0CDE (RETURN)
.................... } 
.................... //==================== 
....................  
.................... // CLEAR LCD LINE 3 BY SENDING BLANK SPACE TO ALL CHARACTORS 
.................... void display_clear_line_3(void) 
0C9A:  CLRF   xAD
.................... {    
.................... unsigned char k; 
.................... unsigned char z = 0; 
....................    send_lcd_command(lcd_line3); 
0C9C:  MOVLW  94
0C9E:  MOVWF  xAE
0CA0:  RCALL  0AFA
....................     
....................    for (k = 20; k > 0 ; k--)  // 
0CA2:  MOVLW  14
0CA4:  MOVWF  xAC
0CA6:  MOVF   xAC,F
0CA8:  BZ    0CB6
....................    { 
....................       send_lcd_data(' '); 
0CAA:  MOVLW  20
0CAC:  MOVWF  xAF
0CAE:  RCALL  0B9C
....................       z++; 
0CB0:  INCF   xAD,F
0CB2:  DECF   xAC,F
0CB4:  BRA    0CA6
....................    } 
0CB6:  GOTO   0CE0 (RETURN)
.................... } 
.................... //==================== 
....................  
.................... // CLEAR LCD LINE 4 BY SENDING BLANK SPACE TO ALL CHARACTORS 
.................... void display_clear_line_4(void) 
0CBA:  CLRF   xAD
.................... {    
.................... unsigned char k; 
.................... unsigned char z = 0; 
....................    send_lcd_command(lcd_line4); 
0CBC:  MOVLW  D4
0CBE:  MOVWF  xAE
0CC0:  RCALL  0AFA
....................     
....................    for (k = 20; k > 0 ; k--)  // 
0CC2:  MOVLW  14
0CC4:  MOVWF  xAC
0CC6:  MOVF   xAC,F
0CC8:  BZ    0CD6
....................    { 
....................       send_lcd_data(' '); 
0CCA:  MOVLW  20
0CCC:  MOVWF  xAF
0CCE:  RCALL  0B9C
....................       z++; 
0CD0:  INCF   xAD,F
0CD2:  DECF   xAC,F
0CD4:  BRA    0CC6
....................    } 
0CD6:  GOTO   0CE2 (RETURN)
.................... } 
.................... //==================== 
....................  
....................  
.................... // CLEAR ENTIRE LCD DISPLAY 
.................... void display_clear_line_all(void) 
.................... { 
....................    display_clear_line_1(); 
0CDA:  BRA    0C5A
....................    display_clear_line_2(); 
0CDC:  BRA    0C7A
....................    display_clear_line_3(); 
0CDE:  BRA    0C9A
....................    display_clear_line_4(); 
0CE0:  BRA    0CBA
0CE2:  GOTO   125E (RETURN)
.................... } 
....................  
....................  
.................... char disp_status_line1_string[] = "RE1 RE2 RE3 RE4 RE5"; 
....................  
.................... void display_status_line1(void)        // PUT STANDARD STATUS LINE ON LCD LINE1 
0CE6:  CLRF   xAD
.................... {    
.................... unsigned char k; 
.................... unsigned char z = 0; 
....................  
....................    send_lcd_command(lcd_line1); 
0CE8:  MOVLW  80
0CEA:  MOVWF  xAE
0CEC:  RCALL  0AFA
....................     
....................    for (k = 19; k > 0 ; k--)   
0CEE:  MOVLW  13
0CF0:  MOVWF  xAC
0CF2:  MOVF   xAC,F
0CF4:  BZ    0D10
....................    { 
....................       send_lcd_data(disp_status_line1_string[z]); 
0CF6:  CLRF   03
0CF8:  MOVF   xAD,W
0CFA:  ADDLW  34
0CFC:  MOVWF  FE9
0CFE:  MOVLW  00
0D00:  ADDWFC 03,W
0D02:  MOVWF  FEA
0D04:  MOVFF  FEF,AF
0D08:  RCALL  0B9C
....................       z++; 
0D0A:  INCF   xAD,F
0D0C:  DECF   xAC,F
0D0E:  BRA    0CF2
....................    }      
0D10:  GOTO   1260 (RETURN)
.................... } 
.................... //==================== 
....................  
.................... char disp_status_line3_string[] = "RE6 RE7 RE8 RE9"; 
....................  
.................... void display_status_line3(void)        // PUT STANDARD STATUS LINE ON LCD LINE3 
0D14:  CLRF   xAD
.................... {    
.................... unsigned char k; 
.................... unsigned char z = 0; 
....................  
....................    send_lcd_command(lcd_line3); 
0D16:  MOVLW  94
0D18:  MOVWF  xAE
0D1A:  RCALL  0AFA
....................     
....................    for (k = 15; k > 0 ; k--)  // 
0D1C:  MOVLW  0F
0D1E:  MOVWF  xAC
0D20:  MOVF   xAC,F
0D22:  BZ    0D3E
....................    { 
....................       send_lcd_data(disp_status_line3_string[z]); 
0D24:  CLRF   03
0D26:  MOVF   xAD,W
0D28:  ADDLW  48
0D2A:  MOVWF  FE9
0D2C:  MOVLW  00
0D2E:  ADDWFC 03,W
0D30:  MOVWF  FEA
0D32:  MOVFF  FEF,AF
0D36:  RCALL  0B9C
....................       z++; 
0D38:  INCF   xAD,F
0D3A:  DECF   xAC,F
0D3C:  BRA    0D20
....................    }      
0D3E:  GOTO   1262 (RETURN)
.................... } 
.................... //==================== 
....................  
....................  
.................... char disp_startup_line1[] = "     Elektor(C)     "; 
.................... char disp_startup_line2[] = "  9 Ch Relay Board  "; 
.................... char disp_startup_line3[] = "      130549-1      "; 
.................... char disp_startup_line4[] = "    Version 1.0     "; 
....................  
.................... void display_startup_message (void)    // DISPLAY STARTUP MESSAGE ON LCD 
*
0BAE:  CLRF   xAD
.................... {    
.................... unsigned char k; 
.................... unsigned char z = 0; 
....................  
....................    send_lcd_command(lcd_line1); 
0BB0:  MOVLW  80
0BB2:  MOVWF  xAE
0BB4:  RCALL  0AFA
....................     
....................    for (k = 20; k > 0 ; k--)  // 
0BB6:  MOVLW  14
0BB8:  MOVWF  xAC
0BBA:  MOVF   xAC,F
0BBC:  BZ    0BD8
....................    { 
....................       send_lcd_data(disp_startup_line1[z]); 
0BBE:  CLRF   03
0BC0:  MOVF   xAD,W
0BC2:  ADDLW  58
0BC4:  MOVWF  FE9
0BC6:  MOVLW  00
0BC8:  ADDWFC 03,W
0BCA:  MOVWF  FEA
0BCC:  MOVFF  FEF,AF
0BD0:  RCALL  0B9C
....................       z++; 
0BD2:  INCF   xAD,F
0BD4:  DECF   xAC,F
0BD6:  BRA    0BBA
....................    }      
....................     
....................    send_lcd_command(lcd_line2); 
0BD8:  MOVLW  C0
0BDA:  MOVWF  xAE
0BDC:  RCALL  0AFA
....................    z = 0; 
0BDE:  CLRF   xAD
....................    for (k = 20; k > 0 ; k--)  // 
0BE0:  MOVLW  14
0BE2:  MOVWF  xAC
0BE4:  MOVF   xAC,F
0BE6:  BZ    0C02
....................    { 
....................       send_lcd_data(disp_startup_line2[z]); 
0BE8:  CLRF   03
0BEA:  MOVF   xAD,W
0BEC:  ADDLW  6D
0BEE:  MOVWF  FE9
0BF0:  MOVLW  00
0BF2:  ADDWFC 03,W
0BF4:  MOVWF  FEA
0BF6:  MOVFF  FEF,AF
0BFA:  RCALL  0B9C
....................       z++; 
0BFC:  INCF   xAD,F
0BFE:  DECF   xAC,F
0C00:  BRA    0BE4
....................    }  
....................     
....................    send_lcd_command(lcd_line3); 
0C02:  MOVLW  94
0C04:  MOVWF  xAE
0C06:  RCALL  0AFA
....................    z = 0; 
0C08:  CLRF   xAD
....................    for (k = 20; k > 0 ; k--)  // 
0C0A:  MOVLW  14
0C0C:  MOVWF  xAC
0C0E:  MOVF   xAC,F
0C10:  BZ    0C2C
....................    { 
....................       send_lcd_data(disp_startup_line3[z]); 
0C12:  CLRF   03
0C14:  MOVF   xAD,W
0C16:  ADDLW  82
0C18:  MOVWF  FE9
0C1A:  MOVLW  00
0C1C:  ADDWFC 03,W
0C1E:  MOVWF  FEA
0C20:  MOVFF  FEF,AF
0C24:  RCALL  0B9C
....................       z++; 
0C26:  INCF   xAD,F
0C28:  DECF   xAC,F
0C2A:  BRA    0C0E
....................    }  
....................     
....................    send_lcd_command(lcd_line4); 
0C2C:  MOVLW  D4
0C2E:  MOVWF  xAE
0C30:  RCALL  0AFA
....................    z = 0; 
0C32:  CLRF   xAD
....................    for (k = 20; k > 0 ; k--)  // 
0C34:  MOVLW  14
0C36:  MOVWF  xAC
0C38:  MOVF   xAC,F
0C3A:  BZ    0C56
....................    { 
....................       send_lcd_data(disp_startup_line4[z]); 
0C3C:  CLRF   03
0C3E:  MOVF   xAD,W
0C40:  ADDLW  97
0C42:  MOVWF  FE9
0C44:  MOVLW  00
0C46:  ADDWFC 03,W
0C48:  MOVWF  FEA
0C4A:  MOVFF  FEF,AF
0C4E:  RCALL  0B9C
....................       z++; 
0C50:  INCF   xAD,F
0C52:  DECF   xAC,F
0C54:  BRA    0C38
....................    }  
0C56:  GOTO   123C (RETURN)
.................... } 
....................  
.................... /* 
....................    display_relay_status 
....................    HERE THE RELAY STATUS IS CHECKED BY READING THE PORT PIN STATUS 
....................    AND AS PER STATE OF RESPACTIVE RELAY STATUS IS DISPLAYED ON LCD 
.................... */ 
.................... void display_relay_status(void) 
.................... {      
....................    send_lcd_command(lcd_line2); 
*
0D42:  MOVLW  C0
0D44:  MOVWF  xAE
0D46:  RCALL  0AFA
....................    send_lcd_data('O'); 
0D48:  MOVLW  4F
0D4A:  MOVWF  xAF
0D4C:  RCALL  0B9C
....................    if(input_state(RLY1) == 1) 
0D4E:  BTFSS  F84.0
0D50:  BRA    0D60
....................    { 
....................       send_lcd_data('N'); 
0D52:  MOVLW  4E
0D54:  MOVWF  xAF
0D56:  RCALL  0B9C
....................       send_lcd_data(' '); 
0D58:  MOVLW  20
0D5A:  MOVWF  xAF
0D5C:  RCALL  0B9C
....................    } 
0D5E:  BRA    0D6C
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0D60:  MOVLW  46
0D62:  MOVWF  xAF
0D64:  RCALL  0B9C
....................       send_lcd_data('F'); 
0D66:  MOVLW  46
0D68:  MOVWF  xAF
0D6A:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line2+4); 
0D6C:  MOVLW  C4
0D6E:  MOVWF  xAE
0D70:  RCALL  0AFA
....................    send_lcd_data('O'); 
0D72:  MOVLW  4F
0D74:  MOVWF  xAF
0D76:  RCALL  0B9C
....................    if(input_state(RLY2) == 1) 
0D78:  BTFSS  F80.5
0D7A:  BRA    0D8A
....................    { 
....................       send_lcd_data('N'); 
0D7C:  MOVLW  4E
0D7E:  MOVWF  xAF
0D80:  RCALL  0B9C
....................       send_lcd_data(' '); 
0D82:  MOVLW  20
0D84:  MOVWF  xAF
0D86:  RCALL  0B9C
....................    } 
0D88:  BRA    0D96
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0D8A:  MOVLW  46
0D8C:  MOVWF  xAF
0D8E:  RCALL  0B9C
....................       send_lcd_data('F'); 
0D90:  MOVLW  46
0D92:  MOVWF  xAF
0D94:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line2+8); 
0D96:  MOVLW  C8
0D98:  MOVWF  xAE
0D9A:  RCALL  0AFA
....................    send_lcd_data('O'); 
0D9C:  MOVLW  4F
0D9E:  MOVWF  xAF
0DA0:  RCALL  0B9C
....................    if(input_state(RLY3) == 1) 
0DA2:  BTFSS  F80.4
0DA4:  BRA    0DB4
....................    { 
....................       send_lcd_data('N'); 
0DA6:  MOVLW  4E
0DA8:  MOVWF  xAF
0DAA:  RCALL  0B9C
....................       send_lcd_data(' '); 
0DAC:  MOVLW  20
0DAE:  MOVWF  xAF
0DB0:  RCALL  0B9C
....................    } 
0DB2:  BRA    0DC0
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0DB4:  MOVLW  46
0DB6:  MOVWF  xAF
0DB8:  RCALL  0B9C
....................       send_lcd_data('F'); 
0DBA:  MOVLW  46
0DBC:  MOVWF  xAF
0DBE:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line2+12); 
0DC0:  MOVLW  CC
0DC2:  MOVWF  xAE
0DC4:  RCALL  0AFA
....................    send_lcd_data('O'); 
0DC6:  MOVLW  4F
0DC8:  MOVWF  xAF
0DCA:  RCALL  0B9C
....................    if(input_state(RLY4) == 1) 
0DCC:  BTFSS  F80.3
0DCE:  BRA    0DDE
....................    { 
....................       send_lcd_data('N'); 
0DD0:  MOVLW  4E
0DD2:  MOVWF  xAF
0DD4:  RCALL  0B9C
....................       send_lcd_data(' '); 
0DD6:  MOVLW  20
0DD8:  MOVWF  xAF
0DDA:  RCALL  0B9C
....................    } 
0DDC:  BRA    0DEA
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0DDE:  MOVLW  46
0DE0:  MOVWF  xAF
0DE2:  RCALL  0B9C
....................       send_lcd_data('F'); 
0DE4:  MOVLW  46
0DE6:  MOVWF  xAF
0DE8:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line2+16); 
0DEA:  MOVLW  D0
0DEC:  MOVWF  xAE
0DEE:  RCALL  0AFA
....................    send_lcd_data('O'); 
0DF0:  MOVLW  4F
0DF2:  MOVWF  xAF
0DF4:  RCALL  0B9C
....................    if(input_state(RLY5) == 1) 
0DF6:  BTFSS  F80.2
0DF8:  BRA    0E08
....................    { 
....................       send_lcd_data('N'); 
0DFA:  MOVLW  4E
0DFC:  MOVWF  xAF
0DFE:  RCALL  0B9C
....................       send_lcd_data(' '); 
0E00:  MOVLW  20
0E02:  MOVWF  xAF
0E04:  RCALL  0B9C
....................    } 
0E06:  BRA    0E14
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0E08:  MOVLW  46
0E0A:  MOVWF  xAF
0E0C:  RCALL  0B9C
....................       send_lcd_data('F'); 
0E0E:  MOVLW  46
0E10:  MOVWF  xAF
0E12:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line4); 
0E14:  MOVLW  D4
0E16:  MOVWF  xAE
0E18:  RCALL  0AFA
....................    send_lcd_data('O'); 
0E1A:  MOVLW  4F
0E1C:  MOVWF  xAF
0E1E:  RCALL  0B9C
....................    if(input_state(RLY6) == 1) 
0E20:  BTFSS  F80.1
0E22:  BRA    0E32
....................    { 
....................       send_lcd_data('N'); 
0E24:  MOVLW  4E
0E26:  MOVWF  xAF
0E28:  RCALL  0B9C
....................       send_lcd_data(' '); 
0E2A:  MOVLW  20
0E2C:  MOVWF  xAF
0E2E:  RCALL  0B9C
....................    } 
0E30:  BRA    0E3E
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0E32:  MOVLW  46
0E34:  MOVWF  xAF
0E36:  RCALL  0B9C
....................       send_lcd_data('F'); 
0E38:  MOVLW  46
0E3A:  MOVWF  xAF
0E3C:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line4+4); 
0E3E:  MOVLW  D8
0E40:  MOVWF  xAE
0E42:  RCALL  0AFA
....................    send_lcd_data('O'); 
0E44:  MOVLW  4F
0E46:  MOVWF  xAF
0E48:  RCALL  0B9C
....................    if(input_state(RLY7) == 1) 
0E4A:  BTFSS  F80.0
0E4C:  BRA    0E5C
....................    { 
....................       send_lcd_data('N'); 
0E4E:  MOVLW  4E
0E50:  MOVWF  xAF
0E52:  RCALL  0B9C
....................       send_lcd_data(' '); 
0E54:  MOVLW  20
0E56:  MOVWF  xAF
0E58:  RCALL  0B9C
....................    } 
0E5A:  BRA    0E68
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0E5C:  MOVLW  46
0E5E:  MOVWF  xAF
0E60:  RCALL  0B9C
....................       send_lcd_data('F'); 
0E62:  MOVLW  46
0E64:  MOVWF  xAF
0E66:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line4+8); 
0E68:  MOVLW  DC
0E6A:  MOVWF  xAE
0E6C:  RCALL  0AFA
....................    send_lcd_data('O'); 
0E6E:  MOVLW  4F
0E70:  MOVWF  xAF
0E72:  RCALL  0B9C
....................    if(input_state(RLY8) == 1) 
0E74:  BTFSS  F84.1
0E76:  BRA    0E86
....................    { 
....................       send_lcd_data('N'); 
0E78:  MOVLW  4E
0E7A:  MOVWF  xAF
0E7C:  RCALL  0B9C
....................       send_lcd_data(' '); 
0E7E:  MOVLW  20
0E80:  MOVWF  xAF
0E82:  RCALL  0B9C
....................    } 
0E84:  BRA    0E92
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0E86:  MOVLW  46
0E88:  MOVWF  xAF
0E8A:  RCALL  0B9C
....................       send_lcd_data('F'); 
0E8C:  MOVLW  46
0E8E:  MOVWF  xAF
0E90:  RCALL  0B9C
....................    }  
....................     
....................    send_lcd_command(lcd_line4+12); 
0E92:  MOVLW  E0
0E94:  MOVWF  xAE
0E96:  RCALL  0AFA
....................    send_lcd_data('O'); 
0E98:  MOVLW  4F
0E9A:  MOVWF  xAF
0E9C:  RCALL  0B9C
....................    if(input_state(RLY9) == 1) 
0E9E:  BTFSS  F84.2
0EA0:  BRA    0EB0
....................    { 
....................       send_lcd_data('N'); 
0EA2:  MOVLW  4E
0EA4:  MOVWF  xAF
0EA6:  RCALL  0B9C
....................       send_lcd_data(' '); 
0EA8:  MOVLW  20
0EAA:  MOVWF  xAF
0EAC:  RCALL  0B9C
....................    } 
0EAE:  BRA    0EBC
....................    else 
....................    { 
....................       send_lcd_data('F'); 
0EB0:  MOVLW  46
0EB2:  MOVWF  xAF
0EB4:  RCALL  0B9C
....................       send_lcd_data('F'); 
0EB6:  MOVLW  46
0EB8:  MOVWF  xAF
0EBA:  RCALL  0B9C
....................    }  
0EBC:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... // SEND STARTUP MESSAGE ON POWER ON 
.................... void send_startup_message(void) 
.................... { 
....................    puts("======================================================================================"); 
*
01C6:  MOVLW  AA
01C8:  MOVWF  FF6
01CA:  MOVLW  07
01CC:  MOVWF  FF7
01CE:  RCALL  01A4
01D0:  MOVLW  0D
01D2:  BTFSS  F9E.4
01D4:  BRA    01D2
01D6:  MOVWF  FAD
01D8:  MOVLW  0A
01DA:  BTFSS  F9E.4
01DC:  BRA    01DA
01DE:  MOVWF  FAD
....................    puts("Elektor(C)"); 
01E0:  MOVLW  02
01E2:  MOVWF  FF6
01E4:  MOVLW  08
01E6:  MOVWF  FF7
01E8:  RCALL  01A4
01EA:  MOVLW  0D
01EC:  BTFSS  F9E.4
01EE:  BRA    01EC
01F0:  MOVWF  FAD
01F2:  MOVLW  0A
01F4:  BTFSS  F9E.4
01F6:  BRA    01F4
01F8:  MOVWF  FAD
....................    puts("Project Name: 9 Channel Relay Control Board with PC Interface"); 
01FA:  MOVLW  0E
01FC:  MOVWF  FF6
01FE:  MOVLW  08
0200:  MOVWF  FF7
0202:  RCALL  01A4
0204:  MOVLW  0D
0206:  BTFSS  F9E.4
0208:  BRA    0206
020A:  MOVWF  FAD
020C:  MOVLW  0A
020E:  BTFSS  F9E.4
0210:  BRA    020E
0212:  MOVWF  FAD
....................    puts("Project Number: 130549-1"); 
0214:  MOVLW  4C
0216:  MOVWF  FF6
0218:  MOVLW  08
021A:  MOVWF  FF7
021C:  RCALL  01A4
021E:  MOVLW  0D
0220:  BTFSS  F9E.4
0222:  BRA    0220
0224:  MOVWF  FAD
0226:  MOVLW  0A
0228:  BTFSS  F9E.4
022A:  BRA    0228
022C:  MOVWF  FAD
....................    puts("Version 1.1"); 
022E:  MOVLW  66
0230:  MOVWF  FF6
0232:  MOVLW  08
0234:  MOVWF  FF7
0236:  RCALL  01A4
0238:  MOVLW  0D
023A:  BTFSS  F9E.4
023C:  BRA    023A
023E:  MOVWF  FAD
0240:  MOVLW  0A
0242:  BTFSS  F9E.4
0244:  BRA    0242
0246:  MOVWF  FAD
....................    puts("======================================================================================"); 
0248:  MOVLW  72
024A:  MOVWF  FF6
024C:  MOVLW  08
024E:  MOVWF  FF7
0250:  RCALL  01A4
0252:  MOVLW  0D
0254:  BTFSS  F9E.4
0256:  BRA    0254
0258:  MOVWF  FAD
025A:  MOVLW  0A
025C:  BTFSS  F9E.4
025E:  BRA    025C
0260:  MOVWF  FAD
....................    puts("INSTRUCTIONS FOR PC COMMANDS:"); 
0262:  MOVLW  CA
0264:  MOVWF  FF6
0266:  MOVLW  08
0268:  MOVWF  FF7
026A:  RCALL  01A4
026C:  MOVLW  0D
026E:  BTFSS  F9E.4
0270:  BRA    026E
0272:  MOVWF  FAD
0274:  MOVLW  0A
0276:  BTFSS  F9E.4
0278:  BRA    0276
027A:  MOVWF  FAD
....................    puts("$RLY#ON& : TURN A RELAY ON (REPLACE # BY RELAY NUMBER 1 TO 9)"); 
027C:  MOVLW  E8
027E:  MOVWF  FF6
0280:  MOVLW  08
0282:  MOVWF  FF7
0284:  RCALL  01A4
0286:  MOVLW  0D
0288:  BTFSS  F9E.4
028A:  BRA    0288
028C:  MOVWF  FAD
028E:  MOVLW  0A
0290:  BTFSS  F9E.4
0292:  BRA    0290
0294:  MOVWF  FAD
....................    puts("$RLY#OFF&: TURN A RELAY OFF (REPLACE # BY RELAY NUMBER 1 TO 9)"); 
0296:  MOVLW  26
0298:  MOVWF  FF6
029A:  MOVLW  09
029C:  MOVWF  FF7
029E:  RCALL  01A4
02A0:  MOVLW  0D
02A2:  BTFSS  F9E.4
02A4:  BRA    02A2
02A6:  MOVWF  FAD
02A8:  MOVLW  0A
02AA:  BTFSS  F9E.4
02AC:  BRA    02AA
02AE:  MOVWF  FAD
....................    puts("$H&      : SHOW THE HELP PAGE AGAIN"); 
02B0:  MOVLW  66
02B2:  MOVWF  FF6
02B4:  MOVLW  09
02B6:  MOVWF  FF7
02B8:  RCALL  01A4
02BA:  MOVLW  0D
02BC:  BTFSS  F9E.4
02BE:  BRA    02BC
02C0:  MOVWF  FAD
02C2:  MOVLW  0A
02C4:  BTFSS  F9E.4
02C6:  BRA    02C4
02C8:  MOVWF  FAD
....................    puts("$STATE&  : PRINT THE CURRENT STATES OF THE RELAYS"); 
02CA:  MOVLW  8A
02CC:  MOVWF  FF6
02CE:  MOVLW  09
02D0:  MOVWF  FF7
02D2:  RCALL  01A4
02D4:  MOVLW  0D
02D6:  BTFSS  F9E.4
02D8:  BRA    02D6
02DA:  MOVWF  FAD
02DC:  MOVLW  0A
02DE:  BTFSS  F9E.4
02E0:  BRA    02DE
02E2:  MOVWF  FAD
02E4:  RETURN 0
....................     
....................    /*puts("COMMAND FROM PC ARE AS FOLLOWS"); 
....................    puts("FOR EXAMPLE TO MAKE RELAY 1 ON SEND '$RLY1ON&'"); 
....................    puts("AND TO MAKE RELAY 1 OFF SEND '$RLY1OF&'");    
....................    puts("TO CONTROL ALL OTHER RELAYS THE COMMAND REMAINS SAME ONLY 5TH CHARACTOR OF THE COMMAND"); 
....................    puts("IS REQUIRED TO CHANGE WITH THE NUMBER OF THE RELAY WHICH REQUIRE TO BE CONTROLLED"); 
....................    puts("IN GIVEN EXAMPLE 5TH CHARACTOR OF COMMAND IS '1' SO IT WILL CONTROL RELAY 1");    
....................    puts("FOR EXAMPLE IF WE REPLACE '1' BY '4' AND COMMAND BECOMES '$RLY4ON&' THIS WILL MAKE");    
....................    puts("RELAY 4 ON"); 
....................    puts("HERE '$' IS USED AS COMMAND START INDICATOR AND '&' SIGN IS USED FOR COMMAND END INDICATOR");*/ 
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY_ON FCMEN IESO
   Word  2: 3C18   PUT NOBROWNOUT BORV19 NOWDT WDT32768
   Word  3: 3F00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
